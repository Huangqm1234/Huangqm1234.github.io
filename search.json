[{"title":"CPP拾遗","url":"/2025/02/11/CPP%E6%8B%BE%E9%81%97/","content":"多态\n动态多态是基于虚函数的。没有虚函数，就没有动态多态。\n多态的具体实现是由编译器在编译的时候实现的，所以被称为动态多态。伪代码如下：\nA()&#123;\tvptr = &amp;A::vftable;&#125;\n\n\n问题1：多态的具体形式。\n答案：父类指针指向子类对象，或者对子类对象的引用。\nclass Base&#123;public:\tvirtual void myvirfunc() &#123;&#125;&#125;;int main()&#123;\tBase* pa = new Base();\tpa-&gt;myvirfunc(); // 多态\tBase base;\tbase.myvirfunc();// 不是多态\tBase* ybase = &amp;base;\tybase-&gt;myvirfunc();// 多态\t\treturn 0;&#125;\nbase.myvirfunc()不是多态的原因在于，其对应的汇编代码如下：\n00007FF6DB741BDC  lea         rcx,[base]  00007FF6DB741BE0  call        Base::myvirfunc (07FF6DB741073h)  00007FF6DB741BE5  nop  \n这里的调用是硬编码的，意味着编译时已经确定调用哪个函数。而ybase-&gt;myvirfunc();的汇编代码如下：\n00007FF6DB741BEE  mov         rax,qword ptr [ybase]  00007FF6DB741BF2  mov         rax,qword ptr [rax]  00007FF6DB741BF5  mov         rcx,qword ptr [ybase]  00007FF6DB741BF9  call        qword ptr [rax]  00007FF6DB741BFB  nop \n这里是在动态的链接，调用的是vptr指向的虚函数表。\n\n\n\n\n","categories":["Programming languages","C++"],"tags":["C++"]},{"title":"Git使用","url":"/2025/03/10/Git%E4%BD%BF%E7%94%A8/","content":"参考视频：十分钟学会正确的github工作流，和开源作者们使用同一套流程_哔哩哔哩_bilibili\n基本操作流\n先将远程仓库复制到本地\n.ksjoujajklya{zoom:50%;}\n\n\n本地分成两个部分\n\nLocal：本地的仓库，即将要告诉git的信息\nDisk：本地的磁盘，源文件真正所在的位置\n\n\n\n新建一个新的分支\n.lglwhtjtvnbe{zoom:50%;}\n编辑新的代码\n.vtxsoxznrexf{zoom:50%;}\n可以使用git diff查看disk下的文件与local中文件的区别\n保存新的代码\n.kfdkngjpwrbe{zoom:50%;}\ngit add命令将会让git知道用户想要提交的文件有哪些，这些文件将被保存在暂存区\n提交新的代码\n.ycgdcmuadjsp{zoom:50%;}\n通过git commit，git将会把修改的内容放到git中。但是此时，github还是不知道更新的\n推送代码\n.cwtpocgkbtxs{zoom:50%;}\n推送后，github会出现一个新的分支\n随主分支更新\n.ekjfnsclbgzu{zoom:50%;}\n在用户提交了一个新的信息（f-commit）后，主分支可能会有更新（update），这时候就需要确认my-feature下的更新是否可以在更新后的主分支下运行。\n更新local branch\n切换到main分支\n.gqsufunvlqxx{zoom:50%;}\n拉取main分支的更新\n.kqwnmjlxscik{zoom:50%;}\n切换到my-feature分支\n.kelxsurjyhtu{zoom:50%;}\n同步update修改\n.sfnhqwfybrkt{zoom:50%;}\ngit rebase意味着先把用户的修改放到一遍，把main最新的修改拿过来，在这个最新的修改基础之上，尝试把f-commit放上去。\n此时可能会出现rebase conflict，这时候就需要手动选择。\n相比较于merge，rebase是在主分支最新的提交上做出了修改。也就是说，相比较于merger会产生一个额外的merge commit，rebase会让提交更线性，更干净。但是公共分支不要使用。\n提交分支的新修改\n.edhhqkxhjjjn{zoom:50%;}\n\n注意\n此时提交必须加上-f\n\n将代码合并到主分支\n.ifgysqbmeuft{zoom:50%;}\n向项目管理者提出pull request\n项目管理者合并代码\n.bvvmpfvypaig{zoom:50%;}\nsquash操作是为了将提交的分支上的所有改变都合并成一个改变，这样可以使主分支的commit history尽可能简洁。简单来讲就是所有的改变都被放入到了update2中，但是commit的结构数量和名字改变了\n删除分支\n当提交结束后，远端的分支就可以通过delete branch删掉了。但是此时本地的git上还有这个分支。\n.hfbxdweyesbd{zoom:50%;}\n本地切换回主分支。\n.jgvbrpjfrbek{zoom:50%;}\n删除掉my-feature分支。\n拉取新的主分支\n.bkfgcrartfnj{zoom:50%;}\n","categories":["Git"],"tags":["Git"]},{"title":"Linux上使用C++","url":"/2025/07/18/Linux%E4%B8%8A%E4%BD%BF%E7%94%A8CPP/","content":"GCC编译器\ngcc可以用于编译C代码（g用于编译C代码）\n编译过程\n.nymqulmgoxcx{zoom: 50%;}\n原始的 test.cpp 文件\n\n\n预处理：生成.i文件\n在这一步骤中，编译器会对宏定义、常量进行处理，比如对常量进行替换操作。\n# -E 表示仅进行预处理。g++ -E test.cpp -o test.i\n.jhopfvsnygli{zoom:50%;}\nCONST_NUM被替换成了40，同时前面的iostream库也被导入近来，所以会突增到28650行。\n\n\n编译：生成.s文件\n将代码转化为汇编语言。\n# -S 表示仅进行汇编g++ -S test.i -o test.s\n.sdvjaxqqwdsq{zoom: 50%;}\n汇编程序。\n\n\n汇编：生成.o文件\n将汇编代码转化为计算机能理解的二进制代码。\n# -C 表示仅进行汇编g++ -c test.s -o test.o\n.wjgpppqcrdxc{zoom:50%;}\n二进制代码。\n\n\n链接：生成可执行的二进制程序。\n将系统中的库链接到当前程序中。\n# -o 将可执行文件命名为指定的名字g++ test.o -o test\n\n\n在实际使用过程中，可以直接使用下面的这一步。其隐式的包含了前面四步。\ng++ test.cpp -o test\ng++编译参数\n\n\n-g编译带调试信息的可执行文件。这意味着代码可以被GDB调试\ng++ -g test.cpp -o test\n\n\n-O[n]优化源代码。编译器会对代码进行优化，比如去除没用过的变量。提高可执行文件的运行速度。\n一般情况下-O2就已经足够了。-O与-O1都是初步优化。\n\n\n-l和-L都用于指定链接库。\n-l为库名。\n-L为库的位置。\n默认情况下，程序都是在/lib，/usr/lib和/usr/local/lib中寻找库，此时无需参数-L。\ng++ -lOfiicialLib test.cpp # 链接的库为OfficialLib\n但如果是自己写的库，需要指定位置，那么就需要使用-L。\ng++ -L/home/abc/MyLibFolder -lMyLib test.cpp\n\n\n-I指定头文件位置。\ng++ test.cpp -Iinclude # include下保存了test.cpp中需要的.h文件\n\n\ng++多文件编译\n.brbhtnmlxijp{zoom:50%;}\n文件结构如图所示。\n\n\n最简单直接的方式\n\n\n# 最简单的方式g++ main.cpp src/swap.cpp -Iinclude -o result.out # -I指明了头文件所在文件夹\n\n\n生成库后再运行\n\n\n静态库版本：将src.cpp生成一个静态库，随后再链接到main.cpp上。\ncd src # 在src文件夹下#在./src/下#开始生成静态库g++ swap.cpp -c -I../include # -c表示生成一个二进制文件 -I制定了swap.h中头文件所在位置\t# 随后，会输出一个swap.o的二进制文件ar rs libSwap.a swap.o # 将二进制文件归档为静态库文件libSwap.a\t# 随后，会输出一个lisSwap.a \t# 此时 src内保存了：libSwap.a  swap.cpp  swap.ocd .. # 回到核心目录下# 此处在./文件夹下# 链接静态库g++ main.cpp -Iinclude -Lsrc -lSwap -o static_main.out # 注意，这里的-l后面写的是Swap是因为，-l操作会自动的在后接上的内容（Swap）前加lib后加.a。此时-l会去寻找libSwap.a\n.hqiuftbzzugs{zoom:50%;}\n\n\n动态库版本：\ncd src#在./src下进行g++ swap.cpp -I../include -fPIC -shared -o libSwap.so # -fPIC 表示生成与位置无关文件，动态链接库必备。 -shared表示生成动态链接库cd ../#在./下进行#链接动态库g++ main.cpp -Iinclude -Lsrc -lSwap -o share_main.out # 同理-l会加上东西，但是编译器会优先尝试动态库（libSwap.so)\n.ujcaclyemacf{zoom:50%;}\n\n\n\n\n\nGDB调试器\n在Vscode中调试代码\n.ufeyjohdysku{zoom:50%;}\n点击图片中的”创建launch.json文件&quot;\nlaunch.json文件的编写如下\n// launch.json&#123;    // 使用 IntelliSense 了解相关属性。     // 悬停以查看现有属性的描述。    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        &#123;            &quot;name&quot;: &quot;my_cmake_exe&quot;,            &quot;type&quot;: &quot;cppdbg&quot;,            &quot;request&quot;: &quot;launch&quot;,            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/build/my_cmake_exe&quot;, //可执行文件所在位置            &quot;args&quot;: [],            &quot;stopAtEntry&quot;: false,            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,            &quot;environment&quot;: [],            &quot;externalConsole&quot;: false,            &quot;MIMode&quot;: &quot;gdb&quot;,            &quot;setupCommands&quot;: [                &#123;                    &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;,                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,                    &quot;ignoreFailures&quot;: true                &#125;            ],            &quot;preLaunchTask&quot;: &quot;Build&quot; // 会调用tasks.json中相对的指令，完成自动编译        &#125;    ]&#125;\n注意修改program选项，指定为my_cmake_exe。同时，在根目录的CMakeLists.txt中应该编写set(CMAKE_BUILD_TYPE Debug)，并且确保set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -Wall&quot;)中没有设置-O2选项，避免因为优化代码，导致调试的不准确。\n随后配置tasks.json文件。\n.ugkterecxeth{zoom:50%;}\n点击“配置默认生成任务”，生成一个tasks.json\n// tasks.json&#123;\t&quot;version&quot;: &quot;2.0.0&quot;,\t&quot;options&quot;: &#123;\t\t&quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;/build&quot; // 相当于 cd $&#123;workspaceFolder&#125;/build\t&#125;,\t&quot;tasks&quot;: [\t\t&#123;\t\t\t&quot;type&quot;: &quot;shell&quot;,\t\t\t&quot;label&quot;: &quot;cmake&quot;, // 这一部分的名称\t\t\t&quot;command&quot;: &quot;cmake&quot;, // 这一部分要执行的命令\t\t\t&quot;args&quot;: [\t\t\t\t&quot;..&quot;\t\t\t]\t\t&#125;,\t\t&#123;\t\t\t&quot;label&quot;: &quot;make&quot;,\t\t\t&quot;group&quot;: &#123;\t\t\t\t&quot;kind&quot;: &quot;build&quot;,\t\t\t\t&quot;isDefault&quot;: true\t\t\t&#125;,\t\t\t&quot;command&quot;: &quot;make&quot;,\t\t\t&quot;args&quot;: []\t\t&#125;,\t\t&#123;\t\t\t&quot;label&quot;: &quot;Build&quot;, // 这个lable应该被输入到launch.json\t\t\t&quot;dependsOrder&quot;: &quot;sequence&quot;, // 按照列出的顺序执行依赖\t\t\t&quot;dependsOn&quot;: [ //依赖项的名字就是前面的label\t\t\t\t&quot;cmake&quot;,\t\t\t\t&quot;make&quot;\t\t\t]\t\t&#125;\t]&#125;\n随后，无需再手动编译，直接执行调试就可以对程序自动的进行编译。\n再次展示文件结构。\n.qnvykjycuuln{zoom:50%;}\nCMake\n跨平台的安装编译工具，可以用于描述所有平台的编译过程。没有Cmake，你就需要给每一个平台都写一个工程构建文件（比如Makefile、Xcode等）。有了Cmake，你只需要与Cmake打交道就可以了，只需要修改CMakeList.txt。\n基本语法\n指令(参数1 参数2 参数3)# 举例set(HELLO hello.cpp)add_executable(hello main.cpp $&#123;HELLO&#125;)IF(HELLO) # IF($&#123;HELLO&#125;)是错误的！！！\n\n\n参数之间需要用空格或分号分开，逗号用不了。\n\n\n指定与大小写无关，参数和变量是大小写相关的。\n\n\n$&#123;&#125;用于变量取值。在IF语句中可以直接使用变量名。\n\n\n常用指令\ncmake_minimum_required(VERSION 2.8.3) # 设置CMake最小版本号为2.8.3project(HELLOWORLD) # 定义工程名#显式定义变量set(SRC hello.cpp Nihao.cpp) # 定义SRC变量并设置为hello.cpp Nihao.cpp# 添加头文件搜索路径 类似g++的-Iinclude_directories(/usr/include ./include) # 将/usr/include ./include 两个文件夹加入到头文件搜索路径# 添加库文件搜索路径 类似g++的-Llink_directories(/usr/lib ./lib) # 将/usr/lib ./lib 两个文件夹加入到库文件搜索路径# 生成库文件add_library(hello SHARED $&#123;SRC&#125;) # 从SRC取值，生成一个叫hello的动态库，最终生成的文件是libhello.so库文件add_library(hello STATIC $&#123;SRC&#125;) # 生成静态库# 增加编译选项add_compile_options(-Wall -std=c++11 -o2) # 编译的时候追加-Wall -std=c++11 -o2这三个命令#生成可执行文件add_executable(main main.cpp) # 将main.cpp生成main的可执行文件add_executable(exename source1 source2 sourceN) # 标准语法# 添加动态链接库 类似g++的-ltarget_link_libraries(main hello) # 将hello这个库链接到main上# 向工程中添加存放源文件的子目录add_subdirectory(src) # 添加src子目录，需要注意的是子目录下必须要有一个CMakeLists.txt！！，哪怕是空的# 给目录内所有的源文件取一个变量名aux_source_directory(dir VARIABLE) # 标准语法aux_source_directory(. SRC) # 案例,将当前目录下所有的源代码取名为SRCadd__executable(main $&#123;SRC&#125;) # 将SRC代指的所有源文件生成可执行文件\n常用变量\nCMAKE_C_FLAGS # gcc编译选项CMAKE_CXX_FLAGS # g++编译选项# 举例，在编译选项后追加一些内容set(CMAKE_CXX_FLAGS &quot;&#123;$CMAKE_CXX_FLAGS&#125; -std=c++11&quot;)CMAKE_BUILD_TYPE # 设置编译类型# 举例set(CMAKE_BUILD_TYPE Debug)set(CMAKE_BUILD_TYPE Release)\n编译流程\n\n\n编写一个CMakeList.txt。\n\n\n执行cmake PATH生成Makefile（linux下）。\n​\tPATH是顶层CMakeList.txt所在的目录，比如在主目录中直接编译写好的CMakeList.txt，就可以写cmake .。\n\n\n执行make进行编译。\n\n\n在编译过程中，有两种构建方式。第一种是内部构建，其意思是指直接在工程主目录下进行cmake指令，直接就是cmake .+make。第二种是外部编译，其含义为现创建一个build目录，进入到build目录后，在目录内部执行cmake ..的命令来编译位于上级目录中的CMakeList.txt，随后的make指令也在build目录中执行。\n","categories":["Programming languages","C++"],"tags":["C++"]},{"title":"Machine Learning","url":"/2025/09/22/Machine-Learning/","content":"线性算法（linear algorithm）\n逻辑回归（Logistic Regression）\n虽然名字为回归，但是实际上实现的是分类。\n所谓分类，就是多大概率分在一起，这个概率是连续的，从而就可以实现回归。\np=f(x)y^={1,p≥0.50,p&lt;0.5但是，这会引出一个问题，f(x)的取值范围是(−∞,+∞)，而概率p的取值范围是[0,1]。\n为了解决这个问题，使用sigmoid函数对f(x)进行处理，将(−∞,+∞)的数据转化为[0,1]的数据。\n.btcuieeumttf{zoom: 50%;}\n现在，新的公式就变成：\nf(x)=wTxp=g(wTx)=11+e−wTxy^={1,p≥0.50,p&lt;0.5为了应对新的这种带有概率的公式，损失函数也要做出改变。\n\n\n损失函数\n\n当真值y=1的时候，若p越小，误差越大，反之越小。\n当真值y=0的时候，若p越大，误差越大，反之越小。\n\n.lehtdntjiuff{zoom: 50%;}\n左边的图就已经初步满足了损失函数的要求，但是使用右边的带有log的更好，这是因为函数在逼近0和逼近1的时候，y值就会变成无穷大，这有益于惩罚。同时，log函数更方便求导。\n对于−ylog(p)−(1−y)log(1−p)这个公式，y的取值只有两种。当y=0的时候，原式变为−log(1−p)，当y=1时候，原式变为−log(p)。\n最终，损失函数如下：\nL(w)=−1m∑i=1m{yilog(pi)+(1−yi)log(1−pi)}pi=g(wTxi)现在，我们的目标转化为：\nargminwL(w)因为逻辑回归的损失函数中存在log和sigmoid，并且其是分段的，所以其没有解析解（超越方程没有解析解）。所以，只有梯度下降能求解逻辑回归的损失函数（最优化理论）。\n\n\n正则化（regularization）\nGeneral：\nL(w)=−1m∑i=1m{yilog(pi)+(1−yi)log(1−pi)}+Δ其中，Δ就是正则化项，其有不同的形式。\n\n\nL1范式与LASSO回归\nΔ=α∑j=1n|wj|为模型添加了先验知识。其告诉模型，参数符合零均值拉普拉斯分布。\n.scddhelyohwi{zoom:67%;}\n\n\nL2范式与Ridge回归\nΔ=12σ2wTw=12σ2∥w∥22计算所有参数分量的平方和。其让参数符合零均值正态分布。σ2是正态分布的方差。\n.vrcjoknsuwdt{zoom:67%;}\n\n\n弹性网络（ElasticNet）\nΔ=λρ∥w∥1+λ(1−ρ)2∥w∥22兼容LASSO回归和Ridge回归，通过λ和ρ来调节两个比例。\n\n\n\n\n\n\n多分类问题\n逻辑回归除了能解决二分类问题，还可以解决多分类问题。核心的原理就是复杂问题简单化。把多分类转化为二分类。\n\n\n转化策略：\n\n\nOne vs One（OvO）：一对一\n将多分类拆开成若干个二分类。\n.wrsawmwwhwgi{zoom: 25%;}\n现在有4类，可以拆成C42=6组二分类。随后就可以训练出6个分类器。\n.tpjgbomxlbmy{zoom: 33%;}\n在预测阶段，把数据分别扔给这六个分类器，每个分类器都会给出一个结果，对这些结果进行统计，投票最高的就是最终结果。\n推广到n个类，就构建Cn2=n(n−1)2个分类器。\n\n\nOne vs Rest （OvR）：一对剩余\n.dzkebyldmhhg{zoom:25%;}\n现在有4类，以每一类为视角，其本身是一类，剩下的三类是一类。这样就可以拆开成4个二分类问题。\n.zrftygqxxsur{zoom:33%;}\n以此训练处4个分类器。在预测阶段，将数据分别放入四个分类器，统计4个分类器输出的结果，票数最高的就是最终结果。\n推广到n个类，就构建n个分类器\n\n\n总结来看（假设二分类的时间复杂度为T）：\n\n\n\n\n\n\n时间复杂度\n准确率\n\n\n\n\nOvO\nCn2∗T=n(n−1)2∗T\n准确度高\n\n\nOvR\nn∗T\n存在类别混淆\n\n\n\nOvO的时间复杂度高（因为其需要更多的分类器），但是准确度高。\n\n\n\n\n2\n3\n\n\n\n\n4\nCn2∗T=n(n−1)2∗T\n6\n\n\n7\nn∗T\n9\n\n\n\n","categories":["Artificial Intelligence"]},{"title":"Paper Reading: Development of the relationship between visual selective attention and auditory change detection","url":"/2025/02/17/Paper-Reading%EF%BC%9ADevelopment-of-the-relationship-between-visual-selective-attention-and-auditory-change-detection/","content":"Development of the relationship between visual selective attention and auditory change detection\n文章链接：Development of the relationship between visual selective attention and auditory change detection - ScienceDirect\n\n\n视觉拥有更高的空间分辨率、听觉拥有更高的视觉分辨率 -&gt; visual selective attention and auditory change detection.\n\n\n听觉在孕期就开始发挥作用，视觉则在出生后开始发挥作用。早起听觉处理占主导，随着年龄增大，成年人转化为视觉主导。\n\n\n\n\n\nA图：成人在视觉定位任务中的 N2 pc 振幅大于儿童，表明成人在视觉选择性注意相关的神经加工强度上高于儿童。\n\n\nB图：儿童和成人的 MMN 振幅无显著差异，说明在听觉变化检测方面，二者在该成分反映的神经机制上无明显年龄差异。\n\n\n","categories":["Paper Reading"],"tags":["Paper"]},{"title":"Paper Reading: Multisensory Causal Inference in the Brain","url":"/2025/02/20/Paper-Reading%EF%BC%9AMultisensory-Causal-Inference-in-the-Brain/","content":"Multisensory Causal Inference in the Brain\n文章链接：Multisensory Causal Inference in the Brain | PLOS Biology\n\n\n融合的两个核心内容：\n\n如何判断两个或多个模态的输入来自同一个object？\n针对来自同一个object的多模态输入，该如何融合？\n\n\n\n针对这个问题，optimal probabilistic inference 又称 是核心的解决方案\n","categories":["Paper Reading"],"tags":["Paper"]},{"title":"Paper Reading: Interactions between auditory statistics processing and visual experience emerge only in late development","url":"/2025/02/17/Paper-Reading%EF%BC%9AInteractions-between-auditory-statistics-processing-and-visual-experience-emerge-only-in-late-development/","content":"Interactions between auditory statistics processing and visual experience emerge only in late development\n文章网址：Interactions between auditory statistics processing and visual experience emerge only in late development: iScience (cell.com)\n\n\n先天性和迟发性视觉剥夺对某些高阶听觉功能都有补偿作用，从而提高了相关表现。\n\n\n对于听觉处理的模式：\n\n局部特征分析：声音频率上的细微差别，比如轿车的启动声音和熄火声音\n全局表征计算：长时间的统计平均。可以理解为对轿车所有操作的声音取平均后得到的一个声音，这个声音可以代表汽车\n\n\n\n\n\n\nA展示了如何对声音进行处理，从而产生不同的样本，为B和C提供数据支持\n\n\nD展示了数据的特征，横轴表示时长，纵轴表示数据间的差异性。差异性越大，越容易分辨。\n\n\n\n\n\nD（样本辨别实验）：展示了视力正常对照组（黑色）、先天性失明组（红色）和迟发性失明组（蓝色）在样本辨别实验中的正确率。迟发性失明组在部分时长下的表现显著差于其他两组。\n\n\nE（纹理辨别实验）：呈现了三组在纹理辨别实验中的正确率。三组表现随时长增加的趋势相似。\n\n\nF 部分：计算了两个实验（样本辨别减去纹理辨别）的相对差异，展示了不同组别该差异随声音片段时长的变化。迟发性失明组在该相对差异上与其他两组存在显著差异。\n\n\nDiscussion\nAuditory statistics processing develops regardless of visual input availability\n\n\n基于过往研究，存在两种预期：一是若视觉经验对听觉处理能力发展至关重要，那么 CB （先天失明）参与者在实验中的表现会逊于视力正常者（SC）；二是鉴于先天性或早期失明个体存在听觉增强的现象，CB 组可能会出现特定的补偿机制，进而在实验中展现出更优的表现\n\n\n实验结果显示，CB 组和 SC 组在实验中的表现并无显著差异。在样本辨别实验中，两组在短时长（40、91ms）时，样本辨别表现均优于纹理辨别；在长时长（478、1093、2500ms）时，纹理辨别表现均更优。这一结果有力地证明了听觉统计处理的发展并不依赖于早期视觉经验。\n\n\nFunctional interplay between selective auditory computations and vision\n\n\n通过对比先天性失明（CB）、视力正常对照组（SC）和迟发性失明（LB）三组的表现，发现虽然早期视觉对听觉统计处理的典型发展并非必需，但在后期发展阶段，失明仍会影响局部特征的处理。\n\n听觉感知功能（例如频率检测和振幅调制）可能在独立于视觉输入的情况下发展，只有在功能发育完成后，感官之间才会产生交互作用。\n后天失明的人可能更注重统计平均而非时间细节，因为其有助于在日常环境中识别声音对象。\n\n\n\nConclusions\n\n\n听觉和视觉都是先独自发展，待各自成熟后才交互作用共同发展。\n\n\n","categories":["Paper Reading"],"tags":["Paper"]},{"title":"Paper Reading: PERCEIVER IO: A GENERAL ARCHITECTURE FOR STRUCTURED INPUTS & OUTPUTS","url":"/2025/05/29/Paper-Reading%EF%BC%9APERCEIVER%20IO%20A%20GENERAL%20ARCHITECTURE%20For%20Structured%20Input%20and%20Output/","content":"\nAbstract\nPerceiver IO的特点：\n\n\n基于Perceiver（[细读经典+代码解析]Perceiver: General Perception with Iterative Attention - 知乎 (zhihu.com)）模型，但是对于output的输出进行优化，使其在size和含义上可以灵活改变。\n\ninput的尺寸也是可以灵活改变的。\n\n\n\n通用性强，可以完成多种任务，不拘泥于特定场景。\n\n\nIntroduction\nOutput的获取是来自于输入到Decode中的Output query array的，并且需要注意到是，Output query array是针对Output进行设计的。其在设计上，与Output的含义高度相关。\n","categories":["Paper Reading"],"tags":["Paper"]},{"title":"Paper Reading: Rethinking Latent Redundancy in Behavior Cloning: An Information Bottleneck Approach for Robot Manipulation","url":"/2025/07/16/Paper-Reading%EF%BC%9ARethinking%20Latent%20Redundancy%20in%20Behavior%20Cloning/","content":"论文题目：Rethinking Latent Redundancy in Behavior Cloning: An Information Bottleneck Approach for Robot Manipulation\n当前Behavior Cloning(BC)为了提升通用性，会增大数据集、增加更多模态。但这样的问题是，无法得知因变量中是否会包含大量的冗余信息。\n","categories":["Paper Reading"],"tags":["Paper"]},{"title":"Paper Reading: Visual Infuences on Auditory Behavioral, Neural, and Perceptual Processes: A Review","url":"/2025/02/04/Paper-Reading%EF%BC%9AVisual-Infuences-on-Auditory-Behavioral,-Neural,-and-Perceptual-Processes-A-Review/","content":"Visual Infuences on Auditory Behavioral, Neural, and Perceptual Processes: A Review\npaper link: Visual Influences on Auditory Behavioral, Neural, and Perceptual Processes: A Review (springer.com)\n文章主要的目标：解释信息是如何整合的。整合的目的是对冗余和互补信息进行处理\n后半部分更多的是在说视觉如何帮助听觉：比如帮助听力损失的人\nVisual Influences on Auditory Perception: Psychophysical Evidence in Humans\nVision Can Enhance Auditory Perceptual Performance\n\n\n一种感觉模态的信息，无论与任务是否相关，都能对另一种感觉模态的感知判断产生影响。这说明不同感觉模态之间存在着密切的联系和相互作用，不是孤立运作的。\n\n\nEnhancement of Auditory Perceptual Performance by Task‑Irrelevant Visual Information\n\n\n与任务无关的视觉能够增强对于听觉的感知。举例而言就是当一个人在判别声音强度的任务时，加入灯光信息会让受试者误认为声音变强了。\n\n\n当视觉刺激领先于听觉刺激时，人们最容易感知到两者是同时发生的。\n\n\nSpatial Ventriloquism：空间腹语效应\n解释：就是在空间中，尽管声音是从B点发出的，但是因为视觉看到A点更符合声音的发出条件（比如电视里一个人在说话），那么就会使人认为声音来自A点。\n\n\n只有当视觉信息可靠性足够高的时候，这种效应才会产生：即视觉对听觉占主导地位\n\n可靠性足够高：听觉信息和视觉信息在空间和时间上的一致性强\n\n\n\n::: tips\n提示\n当听觉信息与在空间和时间上一致的视觉信息配对时，听觉感知表现能够得到提升，无论这些视觉信息与任务是否相关。\n:::\nMechanistic Principles of Visual Influences on Auditory Perception\n\n自下而上是正向传播，自上而下则是反向传播\n\n\n对于Computations部分的解释：蓝色是视觉感知的概率分布，红色是听觉感知的概率分布，紫色是融合后的概率分布，向下的黑色箭头是对结果的最优估计。\n\n\n黑色垂直线表示causal inference、fusion和sensory processing有可能发生的位置\n\n\n\n注意\nsensory processing图中黑色箭头为啥不指概率最高的视觉？\n\n","categories":["Paper Reading"],"tags":["Paper"]},{"title":"Python拾遗","url":"/2025/02/21/Python%E6%8B%BE%E9%81%97/","content":"代码仓库：https://gitee.com/qianminghuang/python-learning.git\n\n提示\nPython中万物皆是对象\n\n\nℹ️ Note\nPython中万物皆是对象\n\n可变类型与不可变类型\n\n\n可变类型：在函数参数传递时，类似于引用。如字典、列表、集和。\n\n\n不可变类型：在函数参数传递时，类似于值传递。如整数、字符串、元素。\n\n\n可以使用.copy()来实现对于 可变对象 的复制，而不要使用=。=会使连个变量指向同一个可变类型对象的地址\nlist1 = [1, 2, 3]list2 = list1.copy()list3 = list1 list1.append(4)print(list1, f&quot;地址为&#123;id(list1)&#125;&quot;)print(list2, f&quot;地址为&#123;id(list2)&#125;&quot;)print(list3, f&quot;地址为&#123;id(list3)&#125;&quot;)\n输出：\n[1, 2, 3, 4] 地址为2227037551360[1, 2, 3] 地址为2227037228800[1, 2, 3, 4] 地址为2227037551360\n但是.copy()本质上还是浅拷贝，当对象中含有指针时，浅拷贝就会产生风险。这时就需要使用深拷贝.deepcopy()。.deepcopy()是依赖于copy()库的。\nimport copyoriginal = [1,2,3, [4, 5]] # [4, 5]本质保存的是指向其的指针list_copy = original.copy() # 浅拷贝list_deepcopy = copy.deepcopy(original) # 深拷贝original[3].append(6) # 修改原列表中的嵌套列表print(f&quot;original = &#123;original&#125;&quot;)print(f&quot;list_copy = &#123;list_copy&#125;&quot;)print(f&quot;list_deepcopy = &#123;list_deepcopy&#125;&quot;)\n输出：\noriginal = [1, 2, 3, [4, 5, 6]]list_copy = [1, 2, 3, [4, 5, 6]]list_deepcopy = [1, 2, 3, [4, 5]]\n假设original指向了 [1,2,3,指针1] ，由于list_copy是浅拷贝而来的，所以其指向的是另一个内存单元的[1,2,3,指针1]。而因为list_deepcopy是深拷贝而来，所以其对列表内部的元素不仅仅是简单的复制值，但遇到指针时，其会开辟一个新的内存单元，然后指向新的内存单元。如下图所示。\n.lxnydhhfqiss{zoom:60%;}\n所以当original中指针1所示指向的空间中的内容被修改后，list_copy中指针1所指向的空间中的内容同样被修改，其二者指向的是同一个内存空间。\n需要注意到是，这张图中只是展示概念。真正的数组保存不可能是一个内存单元存下了所有内容，而是开辟一段连续的内存空间保存这些值，original则指向了这段连续的内存空间的起始地址。\n函数\n::: tips\n提示\n当函数没有返回值的时候，函数默认返回None。\n:::\nNone的应用\n\n\n可以用于if判断，None等价于False\n\n\n用于声明无初始内容的变量\nname = None # 表示后续再给name赋值\n\n\n变量的作用域\n在函数内部，可以使用global关键词来设置全局变量。\ndef test():    global a # 将函数内部的变量声明为全局变量    a = 10    print(f&quot;a在函数中的地址:&#123;id(a)&#125;,值为&#123;a&#125;&quot;)a = 20print(f&quot;a在函数外的地址:&#123;id(a)&#125;,值为&#123;a&#125;&quot;)test()\n输出：\n.gxqpflcdihlc{zoom: 67%;}\nLambda匿名函数\n函数的定义有两种：\n​\tdef关键字的方式，定义有名称的函数，可以重复使用。\n​\tlambda关键字，定义匿名函数，只能临时使用一次。\n匿名函数的定义语法：\nlambda 传入参数: 函数体\n注意，此处函数体只能一行。\n具体案例：\ndef test_func(compute):    result = compute(1, 2)    print(result)def compute(x, y):    return x + ytest_func(compute)# 匿名函数test_func(lambda x, y: x + y)\n输出：\n​\t\nlambda函数具体应用场景：\n\n\n临时构建一个函数，只用一次的场景\n\n\n函数体只用一行\n\n\n函数参数\n不定长参数\n位置传递的不定长参数\n以*开头的参数，其会根据传进参数的位置合并出一个元祖。\ndef user_info_1(*args):    print(args)user_info_1(1, 2, 3, 4, 5)user_info_1(&quot;test&quot;, 10)\n输出：\n.mhmmbsnetcar{zoom: 50%;}\n关键字传递的不定长参数\n以**开头，参数是键值对的形式，返回的是一个字典。\ndef user_info_2(**kwargs):    print(kwargs)    user_info_2(name=&quot;test&quot;, age=10, sex = &quot;男&quot;)user_info_2(10,20) # 报错，不接受位置参数\n输出：\n.fyzhrhggdkwx{zoom: 67%;}\n结合使用：\ndef user_info_3(*args, **kwargs):    print(args)    print(kwargs)user_info_3(1, 2, 3, 4, 5, name=&quot;test&quot;, age=10, sex = &quot;男&quot;)user_info_3(10,20)user_info_3(1, 2, name=&quot;test&quot;, 4, age=10, sex = &quot;男&quot;) # 报错，位置参数不能在关键字参数后面\n输出：\n.ecgomommkyss{zoom:67%;}\n函数作为参数\ndef test_func(compute_func, a, b):    result = compute_func(a, b) + 10    print(result)def compute(x, y):    return x + ytest_func(compute, 1, 2)\n输出：\n.vxpgcqcrbrvu{zoom: 67%;}\n本质上传递的是代码的执行逻辑\n数据类型\n.byxfupzdqfzc{zoom: 67%;}\n\n\n列表：[]，一批数据，可修改\n\n\n元组：()，一批数据，不可修改\n\n\n集和：set()  &#123;&#125;，用于去重操作\n\n\n异常\n了解异常\n异常：程序运行的时候检测到一个错误，这个错误将导致Python解释器无法继续执行。\n也可以理解为一个Bug。\n异常的捕获方式\n\n\n异常捕获的目的\n对可能出现的异常（bug），提前做准备。具体而言就是对Bug进行提醒，并且让整个程序继续运行。这样就可以避免因为一个Bug而导致的整个程序的停止。\n\n\n捕获常规异常\n基本语法：\n  try:\t可能错误的代码except:\t如果出现异常执行的代码\n案例：\n  try:\tf = open(&quot;text.txt&quot;,&#x27;r&#x27;)except:    print(&quot;出现了异常，使用新的方案&quot;)\tf = open(&quot;linux.txt&quot;,&#x27;w&#x27;)\n当try语句中出现异常后，程序不会抛出异常，而是使用except来让程序继续运行\n捕获指定的异常\n基本语法：\ntry:\t可能错误的代码except 指定的异常 as 异常的别名:\t如果出现异常执行的代码\n案例：\ntry:    print(name) # 注意，前文并没有定义nameexcept NameError as e:     print(&quot;name未定义&quot;)    print(e) # 把异常打印出来\n结果：\n.pzzwnebtigog{zoom:80%;}\n捕获多个异常\n基本语法：\ntry:    可能错误的代码except (异常1, 异常2): # 也可以：except (异常1, 异常2) as e\t如果出现异常执行的代码\n捕获所有异常\n最简单的try   except语句就可以捕获所有异常了，但是没法对所捕获到的异常进行输出。\n基本语法：\ntry:    可能错误的代码except Exception as 异常的别名: # Exception可以被认为是所有异常的父类    如果出现异常执行的代码\n通过输出异常的别名就可以看到捕获的异常是什么。\nelse 与 finally\nelse用于表示在没有异常的时候该执行什么行为。\n基本语法：\ntry:    可能错误的代码except Exception as 异常的别名:    如果出现异常执行的代码else:    没有异常时执行的代码finally:    有没有异常都执行的代码\n::: tips\n提示\nfinally中一般都是用来执行资源关闭操作，比如文件的关闭\n:::\n案例：\ntry:    print(&quot;正常执行&quot;)except Exception as e:    print(e)else:    print(&quot;没有异常&quot;)\n输出：\n.spnhichemnhk{zoom:67%;}\n异常的传递\n假设有函数调用关系如下\nmain()|--func01()   |--func02()\n当func02()的代码中出现异常后，异常会向上逐级传递（从func02() -&gt; func01() -&gt; main() ），这条传递线上的任意一个函数有对异常的捕获都将使程序可以继续执行。\n抛出异常\n使用raise可以抛出一个我们想要的异常。\n基础语法：\nraise 异常\n抛出的异常一定要是异常的实例或者使异常的类，即Exception的子类。例如可以是NameError('that is a name error')。因为NameError是Exception的一个子类，所以这里创建了一个异常的匿名对象。\n举例：\nx = 4if x &lt; 5:    raise Exception(&quot;x小于5&quot;)\n输出：\n  File &quot;c:/Users/QianmingHuang/Desktop/Python-Learning/异常.py&quot;, line 32, in raise_func    raise Exception(&quot;x小于5&quot;)Exception: x小于5\n自定义的异常\n用户需要创建一个继承了Exception类的类。\n::: tips\n提示\n有时候需要给一个模块写若干个自定义的异常\n:::\n举例：\nclass ExamError(Exception):    &quot;&quot;&quot;基于考试的自定义异常类&quot;&quot;&quot;    passclass SubmissionError(ExamError):    &quot;&quot;&quot;提交时发生的错误&quot;&quot;&quot;    def __init__(self, message=&quot;Cannot submit after the exam has ended&quot;):        self.message = message        super().__init__(self.message)def submit_exam(student, answers, exam_end_time):    from datetime import datetime    current_time = datetime.now()    if current_time &gt; exam_end_time:        raise SubmissionError(&quot;You cannot submit the exam after the deadline.&quot;)    else:        # 处理提交逻辑        print(&quot;Exam submitted successfully!&quot;)# 假设考试结束时间是之前的某个时间from datetime import datetime, timedeltaexam_end_time = datetime.now() - timedelta(hours=1)try:    submit_exam(&quot;John Doe&quot;, [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;], exam_end_time)except SubmissionError as e:    print(f&quot;Submission failed: &#123;e&#125;&quot;)\n输出结果：\nSubmission failed: You cannot submit the exam after the deadline.\n在上面这个案例中就展示了自定义异常的一个场景。对于提交的异常可以专门写一个类SubmissionError，对于别的异常，比如答题中的异常，也可以专门写一个类来应对。\n面向对象\n类\n变量名 = 类名() # 类的实例化\n类名()创建出了一个匿名对象，变量名也是一个对象，其指向了这个匿名对象。更确切的说，变量名是通过类名()创建出的匿名对象的引用。\n对于每一个对象来说，其都拥有自己的内存空间，保存着自己的属性。但是来自同一个类的不同对象共享类的方法，也就是说类的方法在内存中只有一份，在使用类的方法时，要把对象的引用（可以理解为当前调用此方法的实例的地址，类比C++中的this指针）传递到方法内部。\n在python中有两种类。分别是新式类和旧式类，主要区别是新式类继承自object类，而旧式类不是。自python3开始，一切的类都是新式类\n\n\n__del__方法\n如果说__init__方法类比于 C++ 的构造函数，那么__del__方法就可以类比于 C++ 的析构函数。\n\n\n__str__方法\n此方法的作用是咱输出对象变量的时候，可以输出自定义的内容。\nclass 类名1：    def __str__(self):    \treturn 想输出的字符串对象变量名1 = 类名1()print(对象变量名1)\n\n注意\n__str__方法的返回值必须是 字符串\n\n\n\n私有属性和私有方法\n\n\n定义方法：\n在属性或者方法前面加上两个下划线\nclass Women:    def __init__(self, name):        self.name = name        self.__age = 18  # 私有属性，外部不可访问            def __secret(self):  # 私有方法，外部可不访问        print(&quot;%s 的年龄是 %d&quot; % (self.name, self.__age))\n\n\npython中没有真正意义上的私有\n\n\n在给属性、方法命名是，实际上是对名称作了一些特殊处理，使外界无法访问到\n\n\n通过_类名__私有方法\\属性可以访问私有方法和属性\nxiaohong = Women(&quot;xiaohong&quot;)xiaohong._Women__secret() # 此时就可以访问私有方法啦\n\n\n\n\n类也是对象\n开篇第一句话是：python中万物皆为对象。类也不意外，可以把其看做类对象。\n类对象在内存中只有一个，一个类对象可以创建多个实例。\n正因为类是一个对象，所以其拥有自己的 类属性 和 类方法。二者都可以通过类名·的方式来访问\n\n\n类属性\n仅仅用于记录类的特征，无法用于记录实例特征。\nclass Counter:    # 类属性：用于统计实例数量    instance_count = 0    def __init__(self):        Counter.instance_count += 1 # 通过 类名.类属性 的方式调用\n也可以使用实例.类属性的方式调用类属性（向上查找机制），但是十分不推荐。比如 实例.类属性 = 1 的时候，实际上是给实例增加了一个属性，而不是对类属性的值进行了修改。\n\n\n类方法\n类方法需要用到修饰器@classmethod，其只能访问 类属性 和 类方法。\nclass ParentClass:    class_variable = &quot;这是父类的类变量&quot;    @classmethod # 必须要有@classmethod修饰    def class_method(cls): # 类方法的第一个参数必须是cls        return f&quot;调用了 &#123;cls.__name__&#125; 的类方法，类变量值为: &#123;cls.class_variable&#125;&quot;class ChildClass(ParentClass):    class_variable = &quot;这是子类的类变量&quot;# 子类调用父类的类方法result = ChildClass.class_method()print(result)\n输出：\n调用了 ChildClass 的类方法，类变量值为: 这是子类的类变量\n因为cls的存在，类方法知道其是被哪个类对象调用的。当ChildClass类调用了类方法class_method()后，cls收到了ChildClass类的引用（可以理解为cls此时成为了ChildClass），也就调用了ChildClass的类属性。\nclass Student:    def __init__(self, name, age):        self.name = name        self.age = age    @classmethod    def from_string(cls, info):        name, age = info.split(&#x27; &#x27;)        return cls(name, age)  # 此处等价于Student(name, age)，因为cls指向Student类s1 = Student(&quot;小明&quot;, 10)s2 = Student(&quot;小李&quot;, 20)s3 = Student.from_string(&quot;小红 14&quot;)  # 调用类方法处理特殊输入for s in [s1, s2, s3]:    print(f&quot;s.name = &#123;s.name&#125;, s.age = &#123;s.age&#125;&quot;)\n输出：\ns.name = 小明, s.age = 10s.name = 小李, s.age = 20s.name = 小红, s.age = 14\n\n\n静态方法\n静态方法需要用到修饰器@staticmethod。其既不需要cls也不需要self作为输入，好似独立于类而存在。但是其依旧可以用类名.的方式来访问。\nclass MathUtils:    @staticmethod    def add(a, b):        return a + b# 调用静态方法result = MathUtils.add(3, 5)print(f&quot;3 和 5 相加的结果是: &#123;result&#125;&quot;)print(id(MathUtils))print(id(MathUtils.add))\n输出：\n3 和 5 相加的结果是: 821535934431682153611265360\n可以发现，静态方法并不保存在类对象中。\n嵌套类\n类中是可以再定义类的。\nclass A:    class B:        pass\n这等价于下面的写法：\nclass B:    passclass A:    b = B()\n这就是说类B的实例b是类A的类方法\n继承\n除了继承父类的属性和方法外，还可以对父类的方法进行重写。重写可以分为两种方式。\n\n\n覆盖：在子类中定义了一个和父类同名的方法并且实现。\n\n\n扩展：在子类中定义了一个和父类同名的方法，在其中使用了父类同名的方法。这时就需要super类出场了。\n通过super()的方式生成一个匿名对象，其会按照__mro__属性的顺序来访问父类。\nclass A:    def method(self):        print(&quot;A 的方法&quot;)class B(A):    def method(self):        print(&quot;B 的方法&quot;)        super().method()class C(A):    def method(self):        print(&quot;C 的方法&quot;)        super().method()class D(B, C):    def method(self):        print(&quot;D 的方法&quot;)        super().method()d = D()d.method()print(D.__mro__)\n输出：\nD 的方法B 的方法C 的方法A 的方法(&lt;class &#x27;__main__.D&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)\n可以看出，父类方法调用的顺序就是__mro__中设置的顺序。因此，__mro__将会帮助用户来解决来自不同父类的同名函数的调用问题。\n::: danger\n警告\n但是，最好不要通俗的认为super()就是一个父类对象。可以具体看后面的这两组实验。\n:::\nclass ParentClass:    @classmethod    def class_method(cls):        print(f&quot;调用了 &#123;cls.__name__&#125; 的类方法&quot;)        print(id(cls))class ChildClass(ParentClass):    @classmethod    def class_method(cls):        print(f&quot;调用了 &#123;cls.__name__&#125; 的类方法，现在要调用父类的类方法&quot;)        print(id(cls))        super().class_method()# 调用子类的类方法ChildClass.class_method()\n输出：\n调用了 ChildClass 的类方法，现在要调用父类的类方法2153593471488调用了 ChildClass 的类方法2153593471488\n现在，只将super()改成ParentClass，即父类类名。\nclass ParentClass:    @classmethod    def class_method(cls):        print(f&quot;调用了 &#123;cls.__name__&#125; 的类方法&quot;)        print(id(cls))class ChildClass(ParentClass):    @classmethod    def class_method(cls):        print(f&quot;调用了 &#123;cls.__name__&#125; 的类方法，现在要调用父类的类方法&quot;)        print(id(cls))        ParentClass.class_method() # 此处做出了修改！# 调用子类的类方法ChildClass.class_method()\n输出：\n调用了 ChildClass 的类方法，现在要调用父类的类方法2153593459216调用了 ParentClass 的类方法2153593465824\n可以看出，此时的cls的地址是不一样的。而使用super()的时候，cls的地址则是相同的。\n\n\n多态\n在C++中，多态的实现是通过父类指针或引用指向子类对象实现的。而python中也是如此，只不过因为python中没有指针的显式概念，所以可以进一步理解为：不同的子类对象调用同名的父类方法，产生不同的执行结果。\n# 定义一个基类class Animal:    def speak(self):        pass# 定义 Dog 类，继承自 Animal 类class Dog(Animal):    def speak(self):        return &quot;汪汪汪！&quot;# 定义 Cat 类，继承自 Animal 类class Cat(Animal):    def speak(self):        return &quot;喵喵喵！&quot;# 定义一个函数，接收一个 Animal 类型的对象def animal_speak(animal):    print(animal.speak())# 创建 Dog 和 Cat 的实例dog = Dog()cat = Cat()# 调用 animal_speak 函数，传入不同的对象animal_speak(dog)animal_speak(cat)\n输出：\n汪汪汪！喵喵喵！\n多线程\n每个线程都有属于其自己的一组CPU寄存器（比如指令指针和堆栈指针寄存器），这组CPU寄存器被称为“线程的上下文”。线程的上下文可以被想象为一个线程的“个人信息包”，它包含了线程运行时需要的各种状态信息。\n当线程被调度执行时，CPU 会根据该线程的上下文信息来设置 CPU 寄存器的状态，使其恢复到上次该线程运行时的状态。这样，线程就可以从上次停止的地方继续执行下去。比如，线程在执行一个复杂的数学计算，由于某种原因（如时间片用完）暂停了执行，当时 CPU 寄存器中保存了计算的中间结果和指令指针等信息。当该线程再次被调度执行时，通过其上下文恢复 CPU 寄存器的状态，就能够继续进行之前未完成的计算，而不会丢失之前的工作进度。\n\n注意\n多线程是宏观上的并行，微观上的并发。\n\n线程是可以被中断的。当别的线程正在运行时，线程可以暂时进入睡眠状态，即线程的退让。\n同一个进程下的多个线程是共享内存空间的。\n\n\n线程可以被分为两种：\n\n内核线程：操作系统内核进行管理\n用户线程：用户在程序中管理\n\n\n\nthreading模块\nthreading模块中的Thread类就是用于初始化线程的。可以通过其直接生成一个线程示例。\nimport threadingimport timedef print_numbers():    for i in range(5):        time.sleep(1)        print(i)# 创建线程thread = threading.Thread(target=print_numbers)# 启动线程thread.start()# 等待线程结束thread.join()\n输出：\n01234\n\n\nThread类的__init__函数有用的参数：\n\n\ntarget：线程要执行的目标函数\n\n\nname：线程名字\n\n\nargs：目标函数的参数，按位置传递\n\n\nkwargs：目标函数的参数，按关键字传递\nimport threadingdef print_info(a = 10, b = 20, c = 30, d = 40, e = 50):    print(f&quot;a: &#123;a&#125;, b: &#123;b&#125;, c: &#123;c&#125;, d: &#123;d&#125;, e: &#123;e&#125;&quot;)# 创建线程并同时传递位置参数和关键字参数thread = threading.Thread(target=print_info, args=(1,), kwargs=&#123;&quot;c&quot; : 5, &quot;e&quot;: 4&#125;)# 启动线程thread.start()# 等待线程结束thread.join()\n输出：\na: 1, b: 20, c: 5, d: 40, e: 4\n\n\ndaemon：线程是否为守护线程。\n::: tips\n提示\n守护线程是一种特殊的线程，其会在主线程退出时自动终止。这就意味着，当程序中只剩下守护线程的时候，主线程会直接结束。与之相对的是非守护线程，主线程会等待所有非守护线程执行完毕后才会退出程序。\n:::\nimport threadingimport timedef daemon_function():    print(&quot;Daemon thread started&quot;)    time.sleep(5)    print(&quot;Daemon thread finished&quot;)def non_daemon_function():    print(&quot;Non-daemon thread started&quot;)    time.sleep(2)    print(&quot;Non-daemon thread finished&quot;)# 创建守护线程daemon_thread = threading.Thread(target=daemon_function, daemon=True)# 创建非守护线程non_daemon_thread = threading.Thread(target=non_daemon_function)# 启动线程daemon_thread.start()non_daemon_thread.start()print(&quot;\\nMain thread continues...&quot;)# 主线程不做额外等待，直接结束\n输出：\nDaemon thread startedNon-daemon thread startedMain thread continues...Non-daemon thread finished\n::: danger\n警告\n在jupyter notebook中的结果可能不同。其可能会输出到 Daemon thread finished。\n:::\n\n\n使用场景：\n\n后台任务：当用户需要在程序运行过程中执行一些后台任务，且这些任务不需要保证一定执行完毕时，可以使用守护线程。例如，日志记录、监控系统状态等任务。\n避免资源泄露：如果线程执行的任务在主线程退出时没有必要继续执行，将其设置为守护线程可以避免资源泄漏。比如，一些临时文件的清理工作，如果主线程已经退出，这些清理工作也就没有必要继续执行了。\n\n\n\n\n\n\n\n\n&nbsp;Thread类中的其他方法、属性\n\nstart(self)：启动线程，将调用线程的。\n\n\nrun方法。run(self)：线程在此方法中定义需要执行的代码。\n\n\njoin(self, timeout=None)：等待线程终止。此方法会一直阻塞，直到被调用的线程终止。\n\n\ntimeout参数定义了最多等多少秒。\n\n\nis_alive(self)：判断线程是否还在运行。\n\n\ngetName(self)：获取线程名字。\n\n\nsetName(self)：设置名字。\n\n\nident：线程的唯一标识符。\n\n\nisDaemon(self)：返回是否为守护线程。\n\n\n\n除了直接使用Thread类来初始化一个线程实例，设置一个继承其的子类，并重写其run方法也可以实现多线程。\n\n","categories":["Programming languages","Python"],"tags":["Python"]},{"title":"What is a standard CPP","url":"/2025/10/06/What-is-a-standard-CPP/","content":"From this Blog, I will start writing blogs in English. Since this is my first attempt to write English version blogs and I am not a native speaker of English, there might be some issues with grammar, spelling, or the naturalness of expression. If you ever find anything unclear or awkward, I sincerely apologize and I would really appreciate it if you could tell me the problem by email (brad_huang@outlook.com). Thank you for your understanding and support! Let us get start!\n\nLet us take a look of a piece of code:\n#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;    return 0;&#125;\nAt first glance, how many problems — that is , instance of nonstandard code — can you find? Well, except for int main() , which is standard, everything else is nonstandard. Let me explain it step by step.\nFirstly, the first line #include &lt;bits/stdc++.h&gt; is a universal header. but it is not part of the C++ standard library. Many compilers don’t support it (except gcc). Moreover, it may cause serious naming conflicts and introduce a large number of macros, both of which may lead to unexpected erros — a real disaster for a big project with thousands of lines of code. In addition, this nonstandard header may increase the time spent for compiling. In short,  avoid using bits/stdc++.h !\nSecondly, using namespace std should not be used here at all, because it may cause undesirable name collision. For example, if you define your own class string and include using namespace std, the compiler will be confused when it encounters string. It doesn’t know whether to use your class or the one from the standard library. Thus, do not use using namespace std;. On the contrary, prefix names with std:: (as shown in the example below).\nusing std::cout;using std::endl;std::cout &lt;&lt; &quot;hello world&quot; &lt;&lt; std::endl; // Recommoand !! \nThirdly,  themain function doesn’t need a return statement. Although it is okay for you to write return 0; at the end of main function and I believe many students were taught to include it when they first learned C++, the compiler can automatically insert return 0; at the end of main function. But let me emphasize it again, it is still completely okay for you to write return 0; at end of main function (even I still like to include it myself).\n","categories":["Programming languages","C++"],"tags":["C++"]},{"title":"Hello World","url":"/2025/01/15/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start\nCreate a new post\n$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server\n$ hexo server\nMore info: Server\nGenerate static files\n$ hexo generate\nMore info: Generating\nDeploy to remote sites\n$ hexo deploy\nMore info: Deployment\n"},{"title":"如何配置Hexo","url":"/2025/02/01/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEHEXO/","content":"配置图床\n参考链接：Github+PicGo搭建个人免费图床 - misakivv - 博客园 (cnblogs.com)\n对于博客页的照片上传\n参考解决链接：[2024] hexo图片无法加载究极解决方案_hexo图片显示不出来-CSDN博客\n对于markdown渲染器的优化\n参考链接（优选）：【Hexo】更高级的Markdown渲染器 | Everett Rain\n参考链接：【Hexo】选择更高级的Markdown渲染器_hexo-renderer-marked-CSDN博客\n对于渲染器优化后，mathjax用不了的解决方案\n\n\n在修改了渲染器后，会发现mathjax用不了，此时就需要针对新的渲染器安装一个插件\n如图所示：\n\n\n\n解决方案：\n\n下载一个插件：\n\n$ npm install markdown-it-mathjax3\n\n\n在hexo的_config.yml文件中，加上这个插件的名字\n\n\n\n随后就可以啦！\na=b+c=d+e=f+g\n\n\n\n对于git部署的网络问题\n参考资料：解决git报错：fatal: unable to access ‘https://github.com/…‘: Failed to connect to github.com port 443 a_git failed with a fatal error unable to access-CSDN博客\n直接在git中输入：\ngit config --global --unset http.proxygit config --global --unset https.proxy\n然后挂vpn就好了。（稳定的vpn，或者也可以不挂直接传，没准也能成）\n在输入完终端命令后可以检查一下是否真的删除了：\ngit config --global --list\n如果输出中没有http.proxy和https.proxy，则证明成功。\n测试区\n二级标题测试\n三级标题测试\n四级标题测试\n五级标题测试\n六级标题测试\ntest\ntest\ntest\ntest\ntest\n\n\n对于代码的测试\n\n\n## 此处作为代码测试import numpy as npa = np.array([1,2,3])\n\n\n对于公式的测试\na+b=c\n\niℏ∂∂tψ=−ℏ22m∇2ψ+Vψ​\t对于句子内部的公式：例如x+1=2\n\n\n对于图片的测试\n\n\n本地图片：\n.rjbwkvwghqxk{zoom:33%;}\n\n\n\n\n.csgefjvlxiul{zoom:33%;}\n\n\n​\t网络图片\n\n\n\n\n\n上传图床的照片\n\n\n\n\n折叠，展开内容\n\n\n语法：\n\n\n+++ **点击折叠**这是被隐藏的内容+++\n\n\n效果：\n\n&nbsp;点击折叠这是被隐藏的内容\n\n\n\n自定义容器\n\n\n效果\n\n提示\n这是一个提示\n\n\n注意\n这是一个警告\n\n\ndanger\n这是一个危险信号\n\n\n引用测试\n\n\n成功\n这是一个成功信号\n\n\n\n语法：\n::: tips**提示**这是一个提示:::::: warning**warning**这是一个警告:::::: danger**警告**这是一个危险信号:::::: success**成功**这是一个成功信号:::\n\n\n文本高亮测试：\n\n这是一句测试的文本。\n\n\n\nHe’s a good person\n\n\ntypora容器测试\n\n\n\n💡 Tip\n测试2\n\n\n引用\n\n\nℹ️ Note\nTest-Note\n\n啦啦啦啦来啦\n\n📘 Important\nImportant-test\n\nllalalalallala\n\n⚠️ Warning\nWarning-test\n\n\n❗ Caution\nCaution-test\n\n最初，想使用markdown-it的插件比如markdown-it-alert。但是貌似渲染器在版本上有冲突，并不支持。因此，便使用一种投机取巧的办法，基于markdown-it-container来实现。方式如下：\n输入&gt; [!TIP]&gt; &gt; 测试2&gt; [!NOTE]&gt;&gt; Test-Note&gt; [!IMPORTANT]&gt;&gt; Important-test&gt; [!WARNING]&gt;&gt; Warning-test&gt; [!CAUTION]&gt;&gt; Caution-test输出：::: tip**💡 Tip**测试2:::::: note**ℹ️ Note**Test-Note:::::: important**📘 Important**Important-test:::::: warning**⚠️ Warning**Warning-test:::::: caution**❗ Caution**Caution-test:::\n为了实现自动化的脚本转化，且不影响原始的typora代码，需要在 Hexo根目录/scripts (如果没有这个文件夹就新建一个) 中新建一个叫admonition-convert.js的文件。将下面的代码拷贝进去\nhexo.extend.filter.register(&#x27;before_post_render&#x27;, function(data) &#123;  // 定义类型映射表，包含对应的图标和标题  const typeMap = &#123;    TIP:       &#123; icon: &#x27;💡&#x27;, title: &#x27;Tip&#x27; &#125;,    NOTE:      &#123; icon: &#x27;ℹ️&#x27;, title: &#x27;Note&#x27; &#125;,    IMPORTANT: &#123; icon: &#x27;📘&#x27;, title: &#x27;Important&#x27; &#125;,    WARNING:   &#123; icon: &#x27;⚠️&#x27;, title: &#x27;Warning&#x27; &#125;,    CAUTION:   &#123; icon: &#x27;❗&#x27;, title: &#x27;Caution&#x27; &#125;  &#125;;    // 匹配所有支持的Admonition类型，处理空行和多个连续块  const admonitionRegex = /(^&gt; \\[!([A-Z]+)\\])(\\r?\\n)(&gt; ?\\r?\\n)*((&gt; .*?\\r?\\n)*?)(?=\\r?\\n&gt; \\[!|$)/gm;    data.content = data.content.replace(admonitionRegex, (match, header, type, firstLineBreak, emptyLines, content) =&gt; &#123;    // 检查类型是否在映射表中    if (!typeMap[type]) &#123;      return match; // 不匹配的类型保持原样    &#125;        // 清理内容中的&gt;前缀和多余空行    const cleanedContent = content      .replace(/^&gt; ?/gm, &#x27;&#x27;) // 移除每行开头的&gt;和可能的空格      .replace(/^\\s+|\\s+$/g, &#x27;&#x27;); // 移除首尾空行        // 获取对应的图标和标题    const &#123; icon, title &#125; = typeMap[type];        // 转换为带图标和标题的Typora风格提示块    return `::: $&#123;type.toLowerCase()&#125;**$&#123;icon&#125; $&#123;title&#125;**$&#123;cleanedContent&#125;:::`;  &#125;);    return data;&#125;);\n随后，渲染器就可以支持typora的alert啦\n测试流程图\ngraph TD\n    A[起点] --> B[步骤1]\n    B --> C[步骤2]\n    C --> D[步骤3]\n    D --> E[终点]\n测试表格\n\n\n\n1\n2\n3\n\n\n\n\n4\n+∞\n6\n\n\n7\n8\n9\n\n\n10\n11\n12\n\n\n\n\n\n缩进表格\n\n\n\n\n\n时代\n2\nTime\n\n\n\n\n时代\n+∞\nTime\n\n\n7\n8\n9\n\n\n10\n11\n12\n\n\n\n\n\n进一步缩进的表格\n\n进一步缩进\n\n\n\n\n\n\n1\n2\n3\n\n\n\n\n4\n+∞\n6\n\n\n7\n8\n9\n\n\n10\n11\n12\n\n\n\n\n\n再进一步\n\n再进\n\n\n\n\n\n\n1\n2\n3\n\n\n\n\n4\n+∞\n6\n\n\n7\n8\n9\n\n\n10\n11\n12\n\n\n\n","categories":["Hexo","解决方案"],"tags":["Hexo"]},{"title":"注意力可视化预备","url":"/2025/05/02/%E6%B3%A8%E6%84%8F%E5%8A%9B%E5%8F%AF%E8%A7%86%E5%8C%96%E9%A2%84%E5%A4%87/","content":"图论前提\n\n\n度：与结点连接的边数。\n\n对于有向图\n出度：从结点出去的边。\n入度：进入结点的边。\n\n\n\n邻接矩阵：\n\n\n每一个位置：（a,b）=1表示a到b有一条边\n\n\n每一行的和：表示行头（a）的总出度。\n\n\n每一列的和：表示列头（a）的总入度。\n\n\n邻接矩阵相乘：相乘几次表示路径长度，（a，b）的值表示当前路径长度下的边数。\n\n注意\n使用权重表示的邻接矩阵相乘后的结果不具备类似可解释性。\n\n\n\n\n\n论文参考\nQuantifying Attention Flow in Transformers\n\n\n\nSince in Transformer decoder, future tokens are masked, naturally there is more attention toward initial tokens in the input sequence, and both attention rollout and attention flow will be biased toward these tokens. Hence, to apply these methods on a Transformer decoder, we should first normalize based on the receptive field of attention.\n\n\n\n\n\n存在的问题：有掩码时，此方法可能会失效。\n\n\n解决方案：根据接收域来归一化。\n\n\n注意力矩阵：邻接矩阵的转置。\n\n\n本文对于其内部存在的局限性上\n\n\n使用effective attention weights 替代raw attention(A=0.5Watt+0.5I)进行递归计算\neffective attention weights的目的是从raw attention中找出真正影响结果的那部分，解决raw attention带来的偏差。\n\n\n来源：当输入的token数 大于 注意力头的维度的时候，注意力矩阵A就会存在非零零空间，这意味A是不唯一的。当输入的token数 小于等于 注意力头的维度时，effective attention weights = raw attention。\n\n\n核心思想：找出真正与结果相关的部分，而剩下的部分就是导致A不唯一的部分。（类似于去噪提纯）\nA⋅T=(A+A¯)⋅T\n\n算法初步推导：\n先构建T\nT=EWVH，其中：\n\n\nE是输入嵌入矩阵维度760×512；\n\n\nWV是值投影矩阵维度 512×dv，假设多头注意力中 dv=64\n\n\nH 是头部混合矩阵维度 dv×512。\nrank(T)≤min(ds,dv)=2，因此 T 的零空间维度为 ds−dv=760−64=696。\n\n\nA⊥=A−A∥\n其中A⊥是最后获得的结果，A∥通过A∥T=0获得\n\n\n\n\n基于gradient算 -&gt; Gradient-Based Attribution Methods | SpringerLink\n\n\n\n\nON IDENTIFIABILITY IN TRANSFORMERS\nquery：Q∈Rds×dq\nkey：K∈Rds×dq\nvalue: V∈Rds×dv\n\n由公式1输出的结果叫做contextual word embedding。\nxi∈Rd表示输入Token；eil是第l层输出的contextual word embedding的第i行。\n若干个xi组成了输入矩阵 X∈Rds×d ；若干个 eil 组成了embedding matrix E∈Rds×d。\n\nH∈Rdv×d。公式2的左侧公式表示的意思是：若干个头有若干组Q\\K\\V，这些头输出的结果的尺寸为ds×dv，其中dv=dh， h为头的数量。\n"},{"title":"深度学习：深度生成模型","url":"/2025/02/10/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B/","content":"\n\n判别式模型和生成式模型\n\n判别式：学习类别的边界（比如CNN、RNN）\n生成式：学习数据的分布（VAE、GAN）。比判别式更加复杂\n\n\n\n蒙特卡洛方法\n采样 sampling\n\n\n采样可以减少积分运算量（尤其是概率密度函数特别复杂的时候，可能无法求出解析解），便于统计推断和模型优化。\n\n\n蒙特卡洛采样：从概率分布中抽出样本，得到分布的近似。样本越多，近似的越准\n\n\n\n​\t公式详解：s=∫p(x)f(x)dx=Ep[f(x)]是一个积分形式的期望表达式。其中 p(x)是概率密度函数（当 x 是连续型随机变量时），f(x) 是关于随机变量x的函数 。∫p(x)f(x)dx表示对f(x) 关于概率分布p(x)求积分，得到的结果 s就是函数 f(x)关于分布p(x)的期望Ep[f(x)] 。在概率论和统计学中，期望是随机变量取值的加权平均，这里的权重就是概率密度 p(x)。\ns^n=1n∑i=1nf(x(i)) 是蒙特卡罗估计的形式。这里$ \\boldsymbol{x}^{(i)}是从分布是从分布p(\\boldsymbol{x})$中抽取的第 i个样本 ，n是样本数量。通过抽取n 个样本，计算 f(x) 在这些样本上的取值并求平均，来近似上方公式中的期望 Ep[f(x)]。随着 n增大，根据大数定律，s^n 会依概率收敛到 Ep[f(x)]，即 limn→∞s^n=Ep[f(x)]。 蒙特卡罗方法常用于==难以直接计算积分（期望）==的情况，通过采样和平均来获得近似解。\n\n可以看出，随着采样数的增加，采样的精准度越来越好。在1000个样本的时候，拟合出的曲线更接近p(x)\nImportance Sampling\n\n\n用于估计难以采样的分布的期望值。举例来看就是f(x)在p(x)中的分布可能不是很均匀，在f(x)取值很小的时候在p(x)中的概率很大，而f(x)取值很大的时候在p(x)中的概率很小，这就会让期望的计算难以收敛。\n\n\n用易于采样的参考分布生成样本，然后用权重系数调整估计\n\n此处p(x)不好采样，就用如高斯分布等更为简单的q(x)来近似\n\n\n马尔科夫链蒙特卡洛方法\n\n\nMarkov Chain Monte Carlo (MCMC)\n\n\n一种动态的采样方法。\n\n使用状态转移矩阵，从起始状态开始，转移出一系列的状态，这一系列的状态就是最后的采样结果\n\n.axmsuekaewug{zoom:150%;}\n状态与转移：图中有两个状态“Sunny（晴天）”和“Rainy（雨天）” 。状态之间的带箭头连线和数字表示状态转移概率。比如从“Sunny”状态到自身的转移概率是(0.9)，意味着晴天后还是晴天的概率为(0.9)；从“Sunny”到“Rainy”的转移概率是(0.1) ，即晴天转雨天概率为(0.1) ；从“Rainy”到“Sunny”概率是(0.5)，“Rainy”到自身概率是(0.5) 。\n状态转移矩阵：图中下方的矩阵[0.90.10.50.5]就是该马尔可夫链的状态转移矩阵，矩阵的行和列分别对应“Sunny”和“Rainy”状态，矩阵元素pij表示从状态i转移到状态j的概率。\n::: tips\n提示\n马尔可夫链的核心特性是无后效性，即系统在某个时刻的状态转移只取决于当前状态，与过去状态无关。\n:::\n\n\n好处：不用在整个分布空间中均匀采样，可以进一步提升采样的效率\n\n\n变分推断（Variational Inference）\n参数估计\n\n\n机器学习的本质：从已有数据中估计出参数\n\n求解过程：最优化理论\n\n\n\n两个学派：\n\n\n第一个学派（频率学派）认为，数据就是客观存在的，不受任何影响，所以直接求p(x|z)，即先验概率（在给定参数z的前提下，数据为x的概率）。\n频率学派重点关注基于已有数据对总体参数进行估计。比如估计一枚硬币正面朝上的概率，通过大量抛硬币试验，用正面朝上的频率近似这个概率，不考虑其他潜在 “隐变量” 。他们认为存在一个真实固定的参数值，通过足够多数据和合适统计方法就能逼近这个真值。\n常用方法有最大似然估计(MLE)（L(θ|x)=P(X=x|θ)）。最大似然估计根据样本构造似然函数，找到使似然函数最大的参数值，认为这就是对总体真实参数的最佳估计，强调数据本身对参数估计的作用，不依赖先验信息。\n\n\n第二个学派（贝叶斯学派）认为，观测到的数据x会受到隐变量z的影响，所以他们求的是后验概率p(z|x)。\n.snjpgrqjcmwf{zoom:50%;}\n基于贝叶斯定理，后验概率p(θ|x)可以表示为p(θ|x)=p(x|θ)p(θ)p(x)，其中θ是待估计的参数，x是观测数据。p(x|θ)是似然函数，表示在给定参数θ下观测到数据x的概率；p(θ)是先验概率，反映了在观测数据之前对参数θ的认知；p(x)是证据因子，通常作为归一化常数.\n最大后验估计就是找到使后验概率p(θ|x)最大的参数θ值，即θ^MAP=arg⁡maxθp(θ|x)=arg⁡maxθp(x|θ)p(θ)p(x)。由于p(x)与θ无关，所以等价于θ^MAP=arg⁡maxθp(x|θ)p(θ)。\n与最大似然估计的比较 ：\n\n\n最大似然估计：只考虑似然函数p(x|θ)，通过找到使p(x|θ)最大的θ值来估计参数，没有利用先验信息。当数据量足够大时，最大似然估计能得到较好的结果，但在数据量较少时，可能会出现过拟合或不合理的估计。\n\n\n最大后验估计：综合了似然函数和先验概率，在数据量较少时，先验信息可以起到正则化的作用，帮助避免过拟合，得到更符合实际情况的估计结果。例如，在估计一个硬币正面朝上的概率时，如果没有先验信息，最大似然估计可能会根据少量的投掷结果给出一个极端的估计值。但如果有一个合理的先验，如认为硬币大致是均匀的，那么最大后验估计会在似然函数和先验之间进行平衡，得到一个更合理的估计。\n\n\n::: success\n思考\n感觉贝叶斯学派更屌一些？毕竟人家是直接从当前的数据中直接推算出来了针对当前数据的一组参数。\n:::\n\n\n\n\n通过两个学派的讲解，其实对当前的深度学习可以进行一个分类。对于传统的深度神经网络（如CNN、RNN等）或者称判别式模型，都是基于频率学派的。其是通过最优化理论找到一组参数来尽可能使结果逼近真值。而概率生成模型，都是基于贝叶斯学派的。\n求解最大后验估计\np(z|x)=p(x|z)p(z)p(x)=p(x|z)p(z)∫p(z)p(x|z)dz其中p(x|z)是似然函数(likelihood)，p(z)是先验(prior)，p(x)是evidence。evidence使用积分来求解，但是其很多时候都是一个不可积的积分，无法获得解析解。这时候可以使用马尔科夫链蒙特卡洛方法（MCMC）来取样，近似的求解p(z|x)。\n但是MCMC方法计算较慢，变分推断更适合求解大规模推断，适合并行计算。\n变分推断的算法思路\n\n图中黄色的部分就是要求的目标分布（p(z|x;ϕ)，φ是参数）,红色的曲线q(z;θ)（可以是一个已知的高斯分布，θ是参数）是用来近似目标分布的。现在只需要移动曲线q，使其尽可能多的与黄色部分重叠。绿色曲线代表了最后重叠最大的位置。\n上面的描述是定性的，用定量的数学语言来描述就是最小化两个分布之间的KL散度，具体公式如下：\nminθKL(q(z;θ)||p(z|x;ϕ))目标就是求出一个参数θ ，也就是怎么移动q。\n\n\nKL散度\n\n\n概念：用于衡量两个分布之间的距离，是一种相对熵\n\n\n相对熵 = 交叉熵 - 信息熵\n\n\n\n计算公式：\nKL(q(z;θ)||p(z|x))]=Eq(z;θ)[log⁡q(z;θ)p(z|x)]是针对假定的函数q来求期望。\n\n\n\n\n公式推导\nKL(q(z;θ)||p(z|x))]=Eq[log⁡q(z)p(z|x)]=Eq[log⁡q(z)−log⁡p(z|x)]=Eq[log⁡q(z)−log⁡p(x|z)p(z)p(x)]=Eq[log⁡q(z)]−Eq[log⁡p(x|z)]−Eq[log⁡p(z)]+Eq[log⁡p(x)]=−Eq[log⁡p(x|z)]+KL(q(z)||p(z))+Eq[log⁡p(x)]最后结果里，Eq[log⁡p(x)] 是一个常数（x 是已有的数据，所以 log⁡p(x) 是常数）。前半部分 −Eq[log⁡p(x|z)]+KL(q(z)||p(z)) 为证据下界（Evidence Lower Bound）,缩写为ELBO，那么整个公式可以改写为下面的样子。\nKL(q(z;θ)||p(z|x))]=−Eq[log⁡p(x|z)]+KL(q(z)||p(z))+Eq[log⁡p(x)]=−ELBO+Eq[log⁡p(x)]进一步，最小化KL散度，就是在最大化ELBO。因为Eq[log⁡p(x)]是定值，而ELBO前面又有一个负号。所以式子可进一步改写成下面的样子。\narg⁡minKL(q(z;θ)||p(z|x))]=arg⁡maxELBO=arg⁡maxEq[log⁡p(x|z)]−KL(q(z)||p(z))\n\n案例\n假设我们有若干的数据x（不同颜色的点），我们需要从这些数据中推理出一个参数z，那么就是在求最大后验估计p(z|x)。假设我们有一个高斯混合模型q(z;θ)（灰色阴影），它假设数据是由多个高斯分布（也叫正态分布 ，即形如f(x)=12πσ2e−(x−μ)22σ2 ，其中μ是均值，σ2是方差的分布）混合而成。θ包含了多个高斯分布的参数。\n\n\n可以看到，随着迭代次数的增加，q(z)逐渐可以准确的拟合出不同颜色的点，也就是拟合出了q(z|x)。\n\n\n\n注意\n尽管变分推断（VI）在运行速度上要比MCMC快，但是其需要先对后验分布进行一个假设，即其得到的近似解没有MCMC方法通过采样得到的近似解准确。\n\n变分自编码器（Variational Auto - Encoder，VAE）\n自编码器\n\n输入层（蓝色的x）和输出层(橙色的x^)具有相同的维度。z=e(x)是一个降维后的隐藏层，其维度明显是小于输入层与输出层。\n通过最小化输入数据和解码数据之间的重构误差（loss=||x−x^||2=||x−d(z)||2=||x−d(e(x))||2）来学习参数。\n相比较于PCA，自动编码器因深度神经网络所带来的非线性而具有更强的降维能力。\n::: tips\n提示\nPCA降维后的向量是严格正交的。\n:::\n但是，要注意的一点是，在降维的时候应该尽量确保降维后的数据保存了尽可能多的原始数据信息。自编码器在隐藏层过于小或者编码器过于深的时候可能会导致因降维而丢失大量信息！所以要选择合适深度的编码器与合适尺寸的隐藏层。\n此外，因为自编码器的训练是尽可能减小输入层和输出层之间的误差，所以其并不care降维后的隐藏层（维度对应了潜空间）是否有意义。这将导致从潜空间采样得到的点可能无法对应合理有意义的数据。当训练好后的自编码器用于测试集时，生成的数据可能会毫无意义（可以理解为过拟合于训练数据）。\nVAE基本思想\n此方案引入了正则化来避免过拟合，输入层经过编码后不再是点，而是概率分布。\n\n图中的左列是用AE方案实现的结果，对应了笑的程度。右列是VAE方案的结果，也是对应了笑的程度，但是用概率分布来表达。\n概率生成模型\np(z|x)=p(x|z)p(z)p(x)重温一下贝叶斯公式。AE的方案是在求MLE（最大似然估计）。而VAE方案是在求MAP（最大后验估计）。\n在求p(z|x)最大的时候实际上是在求p(x|z)p(z)最大（因为p(x)与z）无关。所以进一步maxp(z|x)=maxp(x|z)p(z)。为了方便计算，对p(x|z)p(z)取对数，得到ln⁡p(x|z)p(z)=ln⁡p(x|z)+ln⁡p(z)。当p(z)为拉普拉斯分布概率密度函数时，ln⁡p(z)=−ln(2b)−|z|b，此时ln⁡p(z) 等价于引入了一个与|z|相关的项。所以，p(z)可以理解为一个正则项，其用来避免过拟合。\n","categories":["Artificial Intelligence","Deep Learning"],"tags":["Deep Learning"]}]