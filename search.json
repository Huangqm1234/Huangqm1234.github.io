[{"title":"Git使用","url":"/2025/03/10/Git%E4%BD%BF%E7%94%A8/","content":"参考视频：十分钟学会正确的github工作流，和开源作者们使用同一套流程_哔哩哔哩_bilibili\n基本操作流\n先将远程仓库复制到本地\n.xyyegdjukipx{zoom:50%;}\n\n\n本地分成两个部分\n\nLocal：本地的仓库，即将要告诉git的信息\nDisk：本地的磁盘，源文件真正所在的位置\n\n\n\n新建一个新的分支\n.nxmlmfwmcrqm{zoom:50%;}\n编辑新的代码\n.vhhcwvtdcszq{zoom:50%;}\n可以使用git diff查看disk下的文件与local中文件的区别\n保存新的代码\n.aulncamolcxr{zoom:50%;}\ngit add命令将会让git知道用户想要提交的文件有哪些，这些文件将被保存在暂存区\n提交新的代码\n.cxkfrajiyybv{zoom:50%;}\n通过git commit，git将会把修改的内容放到git中。但是此时，github还是不知道更新的\n推送代码\n.jarixfbwlgrg{zoom:50%;}\n推送后，github会出现一个新的分支\n随主分支更新\n.epbnbkyrpezo{zoom:50%;}\n在用户提交了一个新的信息（f-commit）后，主分支可能会有更新（update），这时候就需要确认my-feature下的更新是否可以在更新后的主分支下运行。\n更新local branch\n切换到main分支\n.mlnbgqsvbaoh{zoom:50%;}\n拉取main分支的更新\n.ucblihcjwkcg{zoom:50%;}\n切换到my-feature分支\n.aebtgeduteyv{zoom:50%;}\n同步update修改\n.ohxlpgcrlcyw{zoom:50%;}\ngit rebase意味着先把用户的修改放到一遍，把main最新的修改拿过来，在这个最新的修改基础之上，尝试把f-commit放上去。\n此时可能会出现rebase conflict，这时候就需要手动选择。\n相比较于merge，rebase是在主分支最新的提交上做出了修改。也就是说，相比较于merger会产生一个额外的merge commit，rebase会让提交更线性，更干净。但是公共分支不要使用。\n提交分支的新修改\n.syzvwvdetjua{zoom:50%;}\n\n注意\n此时提交必须加上-f\n\n将代码合并到主分支\n.ogvrvfvuiych{zoom:50%;}\n向项目管理者提出pull request\n项目管理者合并代码\n.sojowhexpiwj{zoom:50%;}\nsquash操作是为了将提交的分支上的所有改变都合并成一个改变，这样可以使主分支的commit history尽可能简洁。简单来讲就是所有的改变都被放入到了update2中，但是commit的结构数量和名字改变了\n删除分支\n当提交结束后，远端的分支就可以通过delete branch删掉了。但是此时本地的git上还有这个分支。\n.skjqqdbqnwxc{zoom:50%;}\n本地切换回主分支。\n.cqwxrfxliqhv{zoom:50%;}\n删除掉my-feature分支。\n拉取新的主分支\n.qleklhnddhpv{zoom:50%;}\n","categories":["Git"],"tags":["Git"]},{"title":"C++拾遗","url":"/2025/02/12/CPP%E6%8B%BE%E9%81%97/","content":"多态\n动态多态是基于虚函数的。没有虚函数，就没有动态多态。\n多态的具体实现是由编译器在编译的时候实现的，所以被称为动态多态。伪代码如下：\nA(){\tvptr = &amp;A::vftable;}\n\n\n问题1：多态的具体形式。\n答案：父类指针指向子类对象，或者对子类对象的引用。\nclass Base{public:\tvirtual void myvirfunc() {}};int main(){\tBase* pa = new Base();\tpa-&gt;myvirfunc(); // 多态\tBase base;\tbase.myvirfunc();// 不是多态\tBase* ybase = &amp;base;\tybase-&gt;myvirfunc();// 多态\t\treturn 0;}\nbase.myvirfunc()不是多态的原因在于，其对应的汇编代码如下：\n00007FF6DB741BDC  lea         rcx,[base]  00007FF6DB741BE0  call        Base::myvirfunc (07FF6DB741073h)  00007FF6DB741BE5  nop  \n这里的调用是硬编码的，意味着编译时已经确定调用哪个函数。而ybase-&gt;myvirfunc();的汇编代码如下：\n00007FF6DB741BEE  mov         rax,qword ptr [ybase]  00007FF6DB741BF2  mov         rax,qword ptr [rax]  00007FF6DB741BF5  mov         rcx,qword ptr [ybase]  00007FF6DB741BF9  call        qword ptr [rax]  00007FF6DB741BFB  nop \n这里是在动态的链接，调用的是vptr指向的虚函数表。\n\n\n\n\n","categories":["Programming languages","C++"],"tags":["C++"]},{"title":"Paper Reading: AN IMAGE IS WORTH 16X16 WORDS: TRANSFORMERS FOR IMAGE RECOGNITION AT SCALE","url":"/2025/03/20/Paper-Reading%EF%BC%9AAN-IMAGE-IS-WORTH-16X16-WORDS-TRANSFORMERS-FOR-IMAGE-RECOGNITION-AT-SCALE/","content":"","categories":["Paper Reading"],"tags":["Paper"]},{"title":"Paper Reading: Development of the relationship between visual selective attention and auditory change detection","url":"/2025/02/17/Paper-Reading%EF%BC%9ADevelopment-of-the-relationship-between-visual-selective-attention-and-auditory-change-detection/","content":"Development of the relationship between visual selective attention and auditory change detection\n文章链接：Development of the relationship between visual selective attention and auditory change detection - ScienceDirect\n\n\n视觉拥有更高的空间分辨率、听觉拥有更高的视觉分辨率 -&gt; visual selective attention and auditory change detection.\n\n\n听觉在孕期就开始发挥作用，视觉则在出生后开始发挥作用。早起听觉处理占主导，随着年龄增大，成年人转化为视觉主导。\n\n\n\n\n\nA图：成人在视觉定位任务中的 N2 pc 振幅大于儿童，表明成人在视觉选择性注意相关的神经加工强度上高于儿童。\n\n\nB图：儿童和成人的 MMN 振幅无显著差异，说明在听觉变化检测方面，二者在该成分反映的神经机制上无明显年龄差异。\n\n\n","categories":["Paper Reading"],"tags":["Paper"]},{"title":"Paper Reading: Interactions between auditory statistics processing and visual experience emerge only in late development","url":"/2025/02/17/Paper-Reading%EF%BC%9AInteractions-between-auditory-statistics-processing-and-visual-experience-emerge-only-in-late-development/","content":"Interactions between auditory statistics processing and visual experience emerge only in late development\n文章网址：Interactions between auditory statistics processing and visual experience emerge only in late development: iScience (cell.com)\n\n\n先天性和迟发性视觉剥夺对某些高阶听觉功能都有补偿作用，从而提高了相关表现。\n\n\n对于听觉处理的模式：\n\n局部特征分析：声音频率上的细微差别，比如轿车的启动声音和熄火声音\n全局表征计算：长时间的统计平均。可以理解为对轿车所有操作的声音取平均后得到的一个声音，这个声音可以代表汽车\n\n\n\n\n\n\nA展示了如何对声音进行处理，从而产生不同的样本，为B和C提供数据支持\n\n\nD展示了数据的特征，横轴表示时长，纵轴表示数据间的差异性。差异性越大，越容易分辨。\n\n\n\n\n\nD（样本辨别实验）：展示了视力正常对照组（黑色）、先天性失明组（红色）和迟发性失明组（蓝色）在样本辨别实验中的正确率。迟发性失明组在部分时长下的表现显著差于其他两组。\n\n\nE（纹理辨别实验）：呈现了三组在纹理辨别实验中的正确率。三组表现随时长增加的趋势相似。\n\n\nF 部分：计算了两个实验（样本辨别减去纹理辨别）的相对差异，展示了不同组别该差异随声音片段时长的变化。迟发性失明组在该相对差异上与其他两组存在显著差异。\n\n\nDiscussion\nAuditory statistics processing develops regardless of visual input availability\n\n\n基于过往研究，存在两种预期：一是若视觉经验对听觉处理能力发展至关重要，那么 CB （先天失明）参与者在实验中的表现会逊于视力正常者（SC）；二是鉴于先天性或早期失明个体存在听觉增强的现象，CB 组可能会出现特定的补偿机制，进而在实验中展现出更优的表现\n\n\n实验结果显示，CB 组和 SC 组在实验中的表现并无显著差异。在样本辨别实验中，两组在短时长（40、91ms）时，样本辨别表现均优于纹理辨别；在长时长（478、1093、2500ms）时，纹理辨别表现均更优。这一结果有力地证明了听觉统计处理的发展并不依赖于早期视觉经验。\n\n\nFunctional interplay between selective auditory computations and vision\n\n\n通过对比先天性失明（CB）、视力正常对照组（SC）和迟发性失明（LB）三组的表现，发现虽然早期视觉对听觉统计处理的典型发展并非必需，但在后期发展阶段，失明仍会影响局部特征的处理。\n\n听觉感知功能（例如频率检测和振幅调制）可能在独立于视觉输入的情况下发展，只有在功能发育完成后，感官之间才会产生交互作用。\n后天失明的人可能更注重统计平均而非时间细节，因为其有助于在日常环境中识别声音对象。\n\n\n\nConclusions\n\n\n听觉和视觉都是先独自发展，待各自成熟后才交互作用共同发展。\n\n\n","categories":["Paper Reading"],"tags":["Paper"]},{"title":"Paper Reading: Multisensory Causal Inference in the Brain","url":"/2025/02/20/Paper-Reading%EF%BC%9AMultisensory-Causal-Inference-in-the-Brain/","content":"Multisensory Causal Inference in the Brain\n文章链接：Multisensory Causal Inference in the Brain | PLOS Biology\n\n\n融合的两个核心内容：\n\n如何判断两个或多个模态的输入来自同一个object？\n针对来自同一个object的多模态输入，该如何融合？\n\n\n\n针对这个问题，optimal probabilistic inference 又称 是核心的解决方案\n","categories":["Paper Reading"],"tags":["Paper"]},{"title":"Paper Reading: Visual Infuences on Auditory Behavioral, Neural, and Perceptual Processes: A Review","url":"/2025/02/04/Paper-Reading%EF%BC%9AVisual-Infuences-on-Auditory-Behavioral,-Neural,-and-Perceptual-Processes-A-Review/","content":"Visual Infuences on Auditory Behavioral, Neural, and Perceptual Processes: A Review\npaper link: Visual Influences on Auditory Behavioral, Neural, and Perceptual Processes: A Review (springer.com)\n文章主要的目标：解释信息是如何整合的。整合的目的是对冗余和互补信息进行处理\n后半部分更多的是在说视觉如何帮助听觉：比如帮助听力损失的人\nVisual Influences on Auditory Perception: Psychophysical Evidence in Humans\nVision Can Enhance Auditory Perceptual Performance\n\n\n一种感觉模态的信息，无论与任务是否相关，都能对另一种感觉模态的感知判断产生影响。这说明不同感觉模态之间存在着密切的联系和相互作用，不是孤立运作的。\n\n\nEnhancement of Auditory Perceptual Performance by Task‑Irrelevant Visual Information\n\n\n与任务无关的视觉能够增强对于听觉的感知。举例而言就是当一个人在判别声音强度的任务时，加入灯光信息会让受试者误认为声音变强了。\n\n\n当视觉刺激领先于听觉刺激时，人们最容易感知到两者是同时发生的。\n\n\nSpatial Ventriloquism：空间腹语效应\n解释：就是在空间中，尽管声音是从B点发出的，但是因为视觉看到A点更符合声音的发出条件（比如电视里一个人在说话），那么就会使人认为声音来自A点。\n\n\n只有当视觉信息可靠性足够高的时候，这种效应才会产生：即视觉对听觉占主导地位\n\n可靠性足够高：听觉信息和视觉信息在空间和时间上的一致性强\n\n\n\n\n提示\n当听觉信息与在空间和时间上一致的视觉信息配对时，听觉感知表现能够得到提升，无论这些视觉信息与任务是否相关。\n\nMechanistic Principles of Visual Influences on Auditory Perception\n\n自下而上是正向传播，自上而下则是反向传播\n\n\n对于Computations部分的解释：蓝色是视觉感知的概率分布，红色是听觉感知的概率分布，紫色是融合后的概率分布，向下的黑色箭头是对结果的最优估计。\n\n\n黑色垂直线表示causal inference、fusion和sensory processing有可能发生的位置\n\n\n\n注意\nsensory processing图中黑色箭头为啥不指概率最高的视觉？\n\n","categories":["Paper Reading"],"tags":["Paper"]},{"title":"Python拾遗","url":"/2025/02/21/Python%E6%8B%BE%E9%81%97/","content":"代码仓库：https://gitee.com/qianminghuang/python-learning.git\n\n提示\nPython中万物皆是对象\n\n可变类型与不可变类型\n\n\n可变类型：在函数参数传递时，类似于引用。如字典、列表、集和。\n\n\n不可变类型：在函数参数传递时，类似于值传递。如整数、字符串、元素。\n\n\n可以使用.copy()来实现对于 可变对象 的复制，而不要使用=。=会使连个变量指向同一个可变类型对象的地址\nlist1 = [1, 2, 3]list2 = list1.copy()list3 = list1 list1.append(4)print(list1, f\"地址为{id(list1)}\")print(list2, f\"地址为{id(list2)}\")print(list3, f\"地址为{id(list3)}\")\n输出：\n[1, 2, 3, 4] 地址为2227037551360[1, 2, 3] 地址为2227037228800[1, 2, 3, 4] 地址为2227037551360\n但是.copy()本质上还是浅拷贝，当对象中含有指针时，浅拷贝就会产生风险。这时就需要使用深拷贝.deepcopy()。.deepcopy()是依赖于copy()库的。\nimport copyoriginal = [1,2,3, [4, 5]] # [4, 5]本质保存的是指向其的指针list_copy = original.copy() # 浅拷贝list_deepcopy = copy.deepcopy(original) # 深拷贝original[3].append(6) # 修改原列表中的嵌套列表print(f\"original = {original}\")print(f\"list_copy = {list_copy}\")print(f\"list_deepcopy = {list_deepcopy}\")\n输出：\noriginal = [1, 2, 3, [4, 5, 6]]list_copy = [1, 2, 3, [4, 5, 6]]list_deepcopy = [1, 2, 3, [4, 5]]\n假设original指向了 [1,2,3,指针1] ，由于list_copy是浅拷贝而来的，所以其指向的是另一个内存单元的[1,2,3,指针1]。而因为list_deepcopy是深拷贝而来，所以其对列表内部的元素不仅仅是简单的复制值，但遇到指针时，其会开辟一个新的内存单元，然后指向新的内存单元。如下图所示。\n.suocnidlrvxo{zoom:60%;}\n所以当original中指针1所示指向的空间中的内容被修改后，list_copy中指针1所指向的空间中的内容同样被修改，其二者指向的是同一个内存空间。\n需要注意到是，这张图中只是展示概念。真正的数组保存不可能是一个内存单元存下了所有内容，而是开辟一段连续的内存空间保存这些值，original则指向了这段连续的内存空间的起始地址。\n函数\n\n提示\n当函数没有返回值的时候，函数默认返回None。\n\nNone的应用\n\n\n可以用于if判断，None等价于False\n\n\n用于声明无初始内容的变量\nname = None # 表示后续再给name赋值\n\n\n变量的作用域\n在函数内部，可以使用global关键词来设置全局变量。\ndef test():    global a # 将函数内部的变量声明为全局变量    a = 10    print(f\"a在函数中的地址:{id(a)},值为{a}\")a = 20print(f\"a在函数外的地址:{id(a)},值为{a}\")test()\n输出：\n.tymbfphxbbpn{zoom: 67%;}\nLambda匿名函数\n函数的定义有两种：\n​\tdef关键字的方式，定义有名称的函数，可以重复使用。\n​\tlambda关键字，定义匿名函数，只能临时使用一次。\n匿名函数的定义语法：\nlambda 传入参数: 函数体\n注意，此处函数体只能一行。\n具体案例：\ndef test_func(compute):    result = compute(1, 2)    print(result)def compute(x, y):    return x + ytest_func(compute)# 匿名函数test_func(lambda x, y: x + y)\n输出：\n​\t\nlambda函数具体应用场景：\n\n\n临时构建一个函数，只用一次的场景\n\n\n函数体只用一行\n\n\n函数参数\n不定长参数\n位置传递的不定长参数\n以*开头的参数，其会根据传进参数的位置合并出一个元祖。\ndef user_info_1(*args):    print(args)user_info_1(1, 2, 3, 4, 5)user_info_1(\"test\", 10)\n输出：\n.bwjfnyecdonw{zoom: 50%;}\n关键字传递的不定长参数\n以**开头，参数是键值对的形式，返回的是一个字典。\ndef user_info_2(**kwargs):    print(kwargs)    user_info_2(name=\"test\", age=10, sex = \"男\")user_info_2(10,20) # 报错，不接受位置参数\n输出：\n.kxnpbkvatsjb{zoom: 67%;}\n结合使用：\ndef user_info_3(*args, **kwargs):    print(args)    print(kwargs)user_info_3(1, 2, 3, 4, 5, name=\"test\", age=10, sex = \"男\")user_info_3(10,20)user_info_3(1, 2, name=\"test\", 4, age=10, sex = \"男\") # 报错，位置参数不能在关键字参数后面\n输出：\n.iocztmewavqs{zoom:67%;}\n函数作为参数\ndef test_func(compute_func, a, b):    result = compute_func(a, b) + 10    print(result)def compute(x, y):    return x + ytest_func(compute, 1, 2)\n输出：\n.pwhynjpicsqv{zoom: 67%;}\n本质上传递的是代码的执行逻辑\n数据类型\n.uhdkubbyphfw{zoom: 67%;}\n\n\n列表：[]，一批数据，可修改\n\n\n元组：()，一批数据，不可修改\n\n\n集和：set()  {}，用于去重操作\n\n\n异常\n了解异常\n异常：程序运行的时候检测到一个错误，这个错误将导致Python解释器无法继续执行。\n也可以理解为一个Bug。\n异常的捕获方式\n\n\n异常捕获的目的\n对可能出现的异常（bug），提前做准备。具体而言就是对Bug进行提醒，并且让整个程序继续运行。这样就可以避免因为一个Bug而导致的整个程序的停止。\n\n\n捕获常规异常\n基本语法：\n  try:\t可能错误的代码except:\t如果出现异常执行的代码\n案例：\n  try:\tf = open(\"text.txt\",'r')except:    print(\"出现了异常，使用新的方案\")\tf = open(\"linux.txt\",'w')\n当try语句中出现异常后，程序不会抛出异常，而是使用except来让程序继续运行\n捕获指定的异常\n基本语法：\ntry:\t可能错误的代码except 指定的异常 as 异常的别名:\t如果出现异常执行的代码\n案例：\ntry:    print(name) # 注意，前文并没有定义nameexcept NameError as e:     print(\"name未定义\")    print(e) # 把异常打印出来\n结果：\n.pgbwjcqisjii{zoom:80%;}\n捕获多个异常\n基本语法：\ntry:    可能错误的代码except (异常1, 异常2): # 也可以：except (异常1, 异常2) as e\t如果出现异常执行的代码\n捕获所有异常\n最简单的try   except语句就可以捕获所有异常了，但是没法对所捕获到的异常进行输出。\n基本语法：\ntry:    可能错误的代码except Exception as 异常的别名: # Exception可以被认为是所有异常的父类    如果出现异常执行的代码\n通过输出异常的别名就可以看到捕获的异常是什么。\nelse 与 finally\nelse用于表示在没有异常的时候该执行什么行为。\n基本语法：\ntry:    可能错误的代码except Exception as 异常的别名:    如果出现异常执行的代码else:    没有异常时执行的代码finally:    有没有异常都执行的代码\n\n提示\nfinally中一般都是用来执行资源关闭操作，比如文件的关闭\n\n案例：\ntry:    print(\"正常执行\")except Exception as e:    print(e)else:    print(\"没有异常\")\n输出：\n.qhcceyegbxuk{zoom:67%;}\n异常的传递\n假设有函数调用关系如下\nmain()|--func01()   |--func02()\n当func02()的代码中出现异常后，异常会向上逐级传递（从func02() -&gt; func01() -&gt; main() ），这条传递线上的任意一个函数有对异常的捕获都将使程序可以继续执行。\n抛出异常\n使用raise可以抛出一个我们想要的异常。\n基础语法：\nraise 异常\n抛出的异常一定要是异常的实例或者使异常的类，即Exception的子类。例如可以是NameError('that is a name error')。因为NameError是Exception的一个子类，所以这里创建了一个异常的匿名对象。\n举例：\nx = 4if x &lt; 5:    raise Exception(\"x小于5\")\n输出：\n  File \"c:/Users/QianmingHuang/Desktop/Python-Learning/异常.py\", line 32, in raise_func    raise Exception(\"x小于5\")Exception: x小于5\n自定义的异常\n用户需要创建一个继承了Exception类的类。\n\n提示\n有时候需要给一个模块写若干个自定义的异常\n\n举例：\nclass ExamError(Exception):    \"\"\"基于考试的自定义异常类\"\"\"    passclass SubmissionError(ExamError):    \"\"\"提交时发生的错误\"\"\"    def __init__(self, message=\"Cannot submit after the exam has ended\"):        self.message = message        super().__init__(self.message)def submit_exam(student, answers, exam_end_time):    from datetime import datetime    current_time = datetime.now()    if current_time &gt; exam_end_time:        raise SubmissionError(\"You cannot submit the exam after the deadline.\")    else:        # 处理提交逻辑        print(\"Exam submitted successfully!\")# 假设考试结束时间是之前的某个时间from datetime import datetime, timedeltaexam_end_time = datetime.now() - timedelta(hours=1)try:    submit_exam(\"John Doe\", [\"A\", \"B\", \"C\"], exam_end_time)except SubmissionError as e:    print(f\"Submission failed: {e}\")\n输出结果：\nSubmission failed: You cannot submit the exam after the deadline.\n在上面这个案例中就展示了自定义异常的一个场景。对于提交的异常可以专门写一个类SubmissionError，对于别的异常，比如答题中的异常，也可以专门写一个类来应对。\n面向对象\n类\n变量名 = 类名() # 类的实例化\n类名()创建出了一个匿名对象，变量名也是一个对象，其指向了这个匿名对象。更确切的说，变量名是通过类名()创建出的匿名对象的引用。\n对于每一个对象来说，其都拥有自己的内存空间，保存着自己的属性。但是来自同一个类的不同对象共享类的方法，也就是说类的方法在内存中只有一份，在使用类的方法时，要把对象的引用（可以理解为当前调用此方法的实例的地址，类比C++中的this指针）传递到方法内部。\n在python中有两种类。分别是新式类和旧式类，主要区别是新式类继承自object类，而旧式类不是。自python3开始，一切的类都是新式类\n\n\n__del__方法\n如果说__init__方法类比于 C++ 的构造函数，那么__del__方法就可以类比于 C++ 的析构函数。\n\n\n__str__方法\n此方法的作用是咱输出对象变量的时候，可以输出自定义的内容。\nclass 类名1：    def __str__(self):    \treturn 想输出的字符串对象变量名1 = 类名1()print(对象变量名1)\n\n注意\n__str__方法的返回值必须是 字符串\n\n\n\n私有属性和私有方法\n\n\n定义方法：\n在属性或者方法前面加上两个下划线\nclass Women:    def __init__(self, name):        self.name = name        self.__age = 18  # 私有属性，外部不可访问            def __secret(self):  # 私有方法，外部可不访问        print(\"%s 的年龄是 %d\" % (self.name, self.__age))\n\n\npython中没有真正意义上的私有\n\n\n在给属性、方法命名是，实际上是对名称作了一些特殊处理，使外界无法访问到\n\n\n通过_类名__私有方法\\属性可以访问私有方法和属性\nxiaohong = Women(\"xiaohong\")xiaohong._Women__secret() # 此时就可以访问私有方法啦\n\n\n\n\n类也是对象\n开篇第一句话是：python中万物皆为对象。类也不意外，可以把其看做类对象。\n类对象在内存中只有一个，一个类对象可以创建多个实例。\n正因为类是一个对象，所以其拥有自己的 类属性 和 类方法。二者都可以通过类名·的方式来访问\n\n\n类属性\n仅仅用于记录类的特征，无法用于记录实例特征。\nclass Counter:    # 类属性：用于统计实例数量    instance_count = 0    def __init__(self):        Counter.instance_count += 1 # 通过 类名.类属性 的方式调用\n也可以使用实例.类属性的方式调用类属性（向上查找机制），但是十分不推荐。比如 实例.类属性 = 1 的时候，实际上是给实例增加了一个属性，而不是对类属性的值进行了修改。\n\n\n类方法\n类方法需要用到修饰器@classmethod，其只能访问 类属性 和 类方法。\nclass ParentClass:    class_variable = \"这是父类的类变量\"    @classmethod # 必须要有@classmethod修饰    def class_method(cls): # 类方法的第一个参数必须是cls        return f\"调用了 {cls.__name__} 的类方法，类变量值为: {cls.class_variable}\"class ChildClass(ParentClass):    class_variable = \"这是子类的类变量\"# 子类调用父类的类方法result = ChildClass.class_method()print(result)\n输出：\n调用了 ChildClass 的类方法，类变量值为: 这是子类的类变量\n因为cls的存在，类方法知道其是被哪个类对象调用的。当ChildClass类调用了类方法class_method()后，cls收到了ChildClass类的引用（可以理解为cls此时成为了ChildClass），也就调用了ChildClass的类属性。\nclass Student:    def __init__(self, name, age):        self.name = name        self.age = age    @classmethod    def from_string(cls, info):        name, age = info.split(' ')        return cls(name, age)  # 此处等价于Student(name, age)，因为cls指向Student类s1 = Student(\"小明\", 10)s2 = Student(\"小李\", 20)s3 = Student.from_string(\"小红 14\")  # 调用类方法处理特殊输入for s in [s1, s2, s3]:    print(f\"s.name = {s.name}, s.age = {s.age}\")\n输出：\ns.name = 小明, s.age = 10s.name = 小李, s.age = 20s.name = 小红, s.age = 14\n\n\n静态方法\n静态方法需要用到修饰器@staticmethod。其既不需要cls也不需要self作为输入，好似独立于类而存在。但是其依旧可以用类名.的方式来访问。\nclass MathUtils:    @staticmethod    def add(a, b):        return a + b# 调用静态方法result = MathUtils.add(3, 5)print(f\"3 和 5 相加的结果是: {result}\")print(id(MathUtils))print(id(MathUtils.add))\n输出：\n3 和 5 相加的结果是: 821535934431682153611265360\n可以发现，静态方法并不保存在类对象中。\n嵌套类\n类中是可以再定义类的。\nclass A:    class B:        pass\n这等价于下面的写法：\nclass B:    passclass A:    b = B()\n这就是说类B的实例b是类A的类方法\n继承\n除了继承父类的属性和方法外，还可以对父类的方法进行重写。重写可以分为两种方式。\n\n\n覆盖：在子类中定义了一个和父类同名的方法并且实现。\n\n\n扩展：在子类中定义了一个和父类同名的方法，在其中使用了父类同名的方法。这时就需要super类出场了。\n通过super()的方式生成一个匿名对象，其会按照__mro__属性的顺序来访问父类。\nclass A:    def method(self):        print(\"A 的方法\")class B(A):    def method(self):        print(\"B 的方法\")        super().method()class C(A):    def method(self):        print(\"C 的方法\")        super().method()class D(B, C):    def method(self):        print(\"D 的方法\")        super().method()d = D()d.method()print(D.__mro__)\n输出：\nD 的方法B 的方法C 的方法A 的方法(&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;)\n可以看出，父类方法调用的顺序就是__mro__中设置的顺序。因此，__mro__将会帮助用户来解决来自不同父类的同名函数的调用问题。\n\n警告\n但是，最好不要通俗的认为super()就是一个父类对象。可以具体看后面的这两组实验。\n\nclass ParentClass:    @classmethod    def class_method(cls):        print(f\"调用了 {cls.__name__} 的类方法\")        print(id(cls))class ChildClass(ParentClass):    @classmethod    def class_method(cls):        print(f\"调用了 {cls.__name__} 的类方法，现在要调用父类的类方法\")        print(id(cls))        super().class_method()# 调用子类的类方法ChildClass.class_method()\n输出：\n调用了 ChildClass 的类方法，现在要调用父类的类方法2153593471488调用了 ChildClass 的类方法2153593471488\n现在，只将super()改成ParentClass，即父类类名。\nclass ParentClass:    @classmethod    def class_method(cls):        print(f\"调用了 {cls.__name__} 的类方法\")        print(id(cls))class ChildClass(ParentClass):    @classmethod    def class_method(cls):        print(f\"调用了 {cls.__name__} 的类方法，现在要调用父类的类方法\")        print(id(cls))        ParentClass.class_method() # 此处做出了修改！# 调用子类的类方法ChildClass.class_method()\n输出：\n调用了 ChildClass 的类方法，现在要调用父类的类方法2153593459216调用了 ParentClass 的类方法2153593465824\n可以看出，此时的cls的地址是不一样的。而使用super()的时候，cls的地址则是相同的。\n\n\n多态\n在C++中，多态的实现是通过父类指针或引用指向子类对象实现的。而python中也是如此，只不过因为python中没有指针的显式概念，所以可以进一步理解为：不同的子类对象调用同名的父类方法，产生不同的执行结果。\n# 定义一个基类class Animal:    def speak(self):        pass# 定义 Dog 类，继承自 Animal 类class Dog(Animal):    def speak(self):        return \"汪汪汪！\"# 定义 Cat 类，继承自 Animal 类class Cat(Animal):    def speak(self):        return \"喵喵喵！\"# 定义一个函数，接收一个 Animal 类型的对象def animal_speak(animal):    print(animal.speak())# 创建 Dog 和 Cat 的实例dog = Dog()cat = Cat()# 调用 animal_speak 函数，传入不同的对象animal_speak(dog)animal_speak(cat)\n输出：\n汪汪汪！喵喵喵！\n多线程\n每个线程都有属于其自己的一组CPU寄存器（比如指令指针和堆栈指针寄存器），这组CPU寄存器被称为“线程的上下文”。线程的上下文可以被想象为一个线程的“个人信息包”，它包含了线程运行时需要的各种状态信息。\n当线程被调度执行时，CPU 会根据该线程的上下文信息来设置 CPU 寄存器的状态，使其恢复到上次该线程运行时的状态。这样，线程就可以从上次停止的地方继续执行下去。比如，线程在执行一个复杂的数学计算，由于某种原因（如时间片用完）暂停了执行，当时 CPU 寄存器中保存了计算的中间结果和指令指针等信息。当该线程再次被调度执行时，通过其上下文恢复 CPU 寄存器的状态，就能够继续进行之前未完成的计算，而不会丢失之前的工作进度。\n\n注意\n多线程是宏观上的并行，微观上的并发。\n\n线程是可以被中断的。当别的线程正在运行时，线程可以暂时进入睡眠状态，即线程的退让。\n同一个进程下的多个线程是共享内存空间的。\n\n\n线程可以被分为两种：\n\n内核线程：操作系统内核进行管理\n用户线程：用户在程序中管理\n\n\n\nthreading模块\nthreading模块中的Thread类就是用于初始化线程的。可以通过其直接生成一个线程示例。\nimport threadingimport timedef print_numbers():    for i in range(5):        time.sleep(1)        print(i)# 创建线程thread = threading.Thread(target=print_numbers)# 启动线程thread.start()# 等待线程结束thread.join()\n输出：\n01234\n\n\nThread类的__init__函数有用的参数：\n\n\ntarget：线程要执行的目标函数\n\n\nname：线程名字\n\n\nargs：目标函数的参数，按位置传递\n\n\nkwargs：目标函数的参数，按关键字传递\nimport threadingdef print_info(a = 10, b = 20, c = 30, d = 40, e = 50):    print(f\"a: {a}, b: {b}, c: {c}, d: {d}, e: {e}\")# 创建线程并同时传递位置参数和关键字参数thread = threading.Thread(target=print_info, args=(1,), kwargs={\"c\" : 5, \"e\": 4})# 启动线程thread.start()# 等待线程结束thread.join()\n输出：\na: 1, b: 20, c: 5, d: 40, e: 4\n\n\ndaemon：线程是否为守护线程。\n\n提示\n守护线程是一种特殊的线程，其会在主线程退出时自动终止。这就意味着，当程序中只剩下守护线程的时候，主线程会直接结束。与之相对的是非守护线程，主线程会等待所有非守护线程执行完毕后才会退出程序。\n\nimport threadingimport timedef daemon_function():    print(\"Daemon thread started\")    time.sleep(5)    print(\"Daemon thread finished\")def non_daemon_function():    print(\"Non-daemon thread started\")    time.sleep(2)    print(\"Non-daemon thread finished\")# 创建守护线程daemon_thread = threading.Thread(target=daemon_function, daemon=True)# 创建非守护线程non_daemon_thread = threading.Thread(target=non_daemon_function)# 启动线程daemon_thread.start()non_daemon_thread.start()print(\"\\nMain thread continues...\")# 主线程不做额外等待，直接结束\n输出：\nDaemon thread startedNon-daemon thread startedMain thread continues...Non-daemon thread finished\n\n警告\n在jupyter notebook中的结果可能不同。其可能会输出到 Daemon thread finished。\n\n\n\n使用场景：\n\n后台任务：当用户需要在程序运行过程中执行一些后台任务，且这些任务不需要保证一定执行完毕时，可以使用守护线程。例如，日志记录、监控系统状态等任务。\n避免资源泄露：如果线程执行的任务在主线程退出时没有必要继续执行，将其设置为守护线程可以避免资源泄漏。比如，一些临时文件的清理工作，如果主线程已经退出，这些清理工作也就没有必要继续执行了。\n\n\n\n\n\n\n\n\n Thread类中的其他方法、属性\n\nstart(self)：启动线程，将调用线程的。\n\n\nrun方法。run(self)：线程在此方法中定义需要执行的代码。\n\n\njoin(self, timeout=None)：等待线程终止。此方法会一直阻塞，直到被调用的线程终止。\n\n\ntimeout参数定义了最多等多少秒。\n\n\nis_alive(self)：判断线程是否还在运行。\n\n\ngetName(self)：获取线程名字。\n\n\nsetName(self)：设置名字。\n\n\nident：线程的唯一标识符。\n\n\nisDaemon(self)：返回是否为守护线程。\n\n\n\n除了直接使用Thread类来初始化一个线程实例，设置一个继承其的子类，并重写其run方法也可以实现多线程。\n\n","categories":["Programming languages","Python"],"tags":["Python"]},{"title":"Hello World","url":"/2025/01/15/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start\nCreate a new post\n$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server\n$ hexo server\nMore info: Server\nGenerate static files\n$ hexo generate\nMore info: Generating\nDeploy to remote sites\n$ hexo deploy\nMore info: Deployment\n"},{"title":"如何配置Hexo","url":"/2025/02/02/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEHEXO/","content":"配置图床\n参考链接：Github+PicGo搭建个人免费图床 - misakivv - 博客园 (cnblogs.com)\n对于博客页的照片上传\n参考解决链接：[2024] hexo图片无法加载究极解决方案_hexo图片显示不出来-CSDN博客\n对于markdown渲染器的优化\n参考链接（优选）：【Hexo】更高级的Markdown渲染器 | Everett Rain\n参考链接：【Hexo】选择更高级的Markdown渲染器_hexo-renderer-marked-CSDN博客\n对于渲染器优化后，mathjax用不了的解决方案\n\n\n在修改了渲染器后，会发现mathjax用不了，此时就需要针对新的渲染器安装一个插件\n如图所示：\n\n\n\n解决方案：\n\n下载一个插件：\n\n$ npm install markdown-it-mathjax3\n\n\n在hexo的_config.yml文件中，加上这个插件的名字\n\n\n\n随后就可以啦！\n\n\n\n\n对于git部署的网络问题\n参考资料：解决git报错：fatal: unable to access ‘https://github.com/…‘: Failed to connect to github.com port 443 a_git failed with a fatal error unable to access-CSDN博客\n直接在git中输入：\ngit config --global --unset http.proxygit config --global --unset https.proxy\n然后挂vpn就好了。（稳定的vpn，或者也可以不挂直接传，没准也能成）\n在输入完终端命令后可以检查一下是否真的删除了：\ngit config --global --list\n如果输出中没有http.proxy和https.proxy，则证明成功。\n测试区\n二级标题测试\n三级标题测试\n四级标题测试\n五级标题测试\n六级标题测试\ntest\ntest\ntest\ntest\ntest\n\n\n对于代码的测试\n\n\n## 此处作为代码测试import numpy as npa = np.array([1,2,3])\n\n\n对于公式的测试\n\n\n​\t对于句子内部的公式：例如\n\n\n对于图片的测试\n\n本地图片：\n\n\n\n.niwejtnrsgmj{zoom:33%;}\n\n\n​\t网络图片\n\n\n\n\n\n上传图床的照片\n\n\n\n折叠，展开内容\n\n\n语法：\n\n\n+++ **点击折叠**这是被隐藏的内容+++\n\n\n效果：\n\n 点击折叠这是被隐藏的内容\n\n\n\n自定义容器\n\n\n效果\n\n提示\n这是一个提示\n\n\n注意\n这是一个警告\n\n\n警告\n这是一个危险信号\n\n\n成功\n这是一个成功信号\n\n\n\n语法：\n::: tips**提示**这是一个提示:::::: warning**注意**这是一个警告:::::: danger**警告**这是一个危险信号:::::: success**成功**这是一个成功信号:::\n\n\n文本高亮测试：\n\n这是一句测试的文本。\n\n\n\nHe’s a good person\n","categories":["Hexo","解决方案"],"tags":["Hexo"]},{"title":"深度学习：深度生成模型","url":"/2025/02/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B/","content":"\n\n判别式模型和生成式模型\n\n判别式：学习类别的边界（比如CNN、RNN）\n生成式：学习数据的分布（VAE、GAN）。比判别式更加复杂\n\n\n\n蒙特卡洛方法\n采样 sampling\n\n\n采样可以减少积分运算量（尤其是概率密度函数特别复杂的时候，可能无法求出解析解），便于统计推断和模型优化。\n\n\n蒙特卡洛采样：从概率分布中抽出样本，得到分布的近似。样本越多，近似的越准\n\n\n\n​\t公式详解：是一个积分形式的期望表达式。其中 是概率密度函数（当  是连续型随机变量时）， 是关于随机变量的函数 。表示对 关于概率分布p求积分，得到的结果 就是函数 关于分布的期望 。在概率论和统计学中，期望是随机变量取值的加权平均，这里的权重就是概率密度 。\n 是蒙特卡罗估计的形式。这里$ \\boldsymbol{x}^{(i)}是从分布p(\\boldsymbol{x})$中抽取的第 个样本 ，是样本数量。通过抽取 个样本，计算  在这些样本上的取值并求平均，来近似上方公式中的期望 。随着 增大，根据大数定律， 会依概率收敛到 ，即 。 蒙特卡罗方法常用于==难以直接计算积分（期望）==的情况，通过采样和平均来获得近似解。\n\n可以看出，随着采样数的增加，采样的精准度越来越好。在1000个样本的时候，拟合出的曲线更接近\nImportance Sampling\n\n\n用于估计难以采样的分布的期望值。举例来看就是在中的分布可能不是很均匀，在取值很小的时候在中的概率很大，而取值很大的时候在中的概率很小，这就会让期望的计算难以收敛。\n\n\n用易于采样的参考分布生成样本，然后用权重系数调整估计\n\n此处不好采样，就用如高斯分布等更为简单的来近似\n\n\n马尔科夫链蒙特卡洛方法\n\n\nMarkov Chain Monte Carlo (MCMC)\n\n\n一种动态的采样方法。\n\n使用状态转移矩阵，从起始状态开始，转移出一系列的状态，这一系列的状态就是最后的采样结果\n\n.gndaisgndwaz{zoom:150%;}\n状态与转移：图中有两个状态“Sunny（晴天）”和“Rainy（雨天）” 。状态之间的带箭头连线和数字表示状态转移概率。比如从“Sunny”状态到自身的转移概率是(0.9)，意味着晴天后还是晴天的概率为(0.9)；从“Sunny”到“Rainy”的转移概率是(0.1) ，即晴天转雨天概率为(0.1) ；从“Rainy”到“Sunny”概率是(0.5)，“Rainy”到自身概率是(0.5) 。\n状态转移矩阵：图中下方的矩阵就是该马尔可夫链的状态转移矩阵，矩阵的行和列分别对应“Sunny”和“Rainy”状态，矩阵元素表示从状态转移到状态的概率。\n\n提示\n马尔可夫链的核心特性是无后效性，即系统在某个时刻的状态转移只取决于当前状态，与过去状态无关。\n\n\n\n好处：不用在整个分布空间中均匀采样，可以进一步提升采样的效率\n\n\n变分推断（Variational Inference）\n参数估计\n\n\n机器学习的本质：从已有数据中估计出参数\n\n求解过程：最优化理论\n\n\n\n两个学派：\n\n\n第一个学派（频率学派）认为，数据就是客观存在的，不受任何影响，所以直接求，即先验概率（在给定参数的前提下，数据为的概率）。\n频率学派重点关注基于已有数据对总体参数进行估计。比如估计一枚硬币正面朝上的概率，通过大量抛硬币试验，用正面朝上的频率近似这个概率，不考虑其他潜在 “隐变量” 。他们认为存在一个真实固定的参数值，通过足够多数据和合适统计方法就能逼近这个真值。\n常用方法有最大似然估计(MLE)（）。最大似然估计根据样本构造似然函数，找到使似然函数最大的参数值，认为这就是对总体真实参数的最佳估计，强调数据本身对参数估计的作用，不依赖先验信息。\n\n\n第二个学派（贝叶斯学派）认为，观测到的数据会受到隐变量的影响，所以他们求的是后验概率。\n.cmkmakuwxivd{zoom:50%;}\n基于贝叶斯定理，后验概率可以表示为，其中是待估计的参数，是观测数据。是似然函数，表示在给定参数下观测到数据的概率；是先验概率，反映了在观测数据之前对参数的认知；是证据因子，通常作为归一化常数.\n最大后验估计就是找到使后验概率最大的参数值，即。由于与无关，所以等价于。\n与最大似然估计的比较 ：\n\n\n最大似然估计：只考虑似然函数，通过找到使最大的值来估计参数，没有利用先验信息。当数据量足够大时，最大似然估计能得到较好的结果，但在数据量较少时，可能会出现过拟合或不合理的估计。\n\n\n最大后验估计：综合了似然函数和先验概率，在数据量较少时，先验信息可以起到正则化的作用，帮助避免过拟合，得到更符合实际情况的估计结果。例如，在估计一个硬币正面朝上的概率时，如果没有先验信息，最大似然估计可能会根据少量的投掷结果给出一个极端的估计值。但如果有一个合理的先验，如认为硬币大致是均匀的，那么最大后验估计会在似然函数和先验之间进行平衡，得到一个更合理的估计。\n\n\n\n思考\n感觉贝叶斯学派更屌一些？毕竟人家是直接从当前的数据中直接推算出来了针对当前数据的一组参数。\n\n\n\n\n\n通过两个学派的讲解，其实对当前的深度学习可以进行一个分类。对于传统的深度神经网络（如CNN、RNN等）或者称判别式模型，都是基于频率学派的。其是通过最优化理论找到一组参数来尽可能使结果逼近真值。而概率生成模型，都是基于贝叶斯学派的。\n","categories":["Artificial Intelligence","Deep Learning"],"tags":["Deep Learning"]}]