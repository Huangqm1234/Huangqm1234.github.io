[{"title":"C++拾遗","url":"/2025/02/12/CPP%E6%8B%BE%E9%81%97/","content":"多态\n动态多态是基于虚函数的。没有虚函数，就没有动态多态。\n多态的具体实现是由编译器在编译的时候实现的，所以被称为动态多态。伪代码如下：\nA(){\tvptr = &amp;A::vftable;}\n\n\n问题1：多态的具体形式。\n答案：父类指针指向子类对象，或者对子类对象的引用。\nclass Base{public:\tvirtual void myvirfunc() {}};int main(){\tBase* pa = new Base();\tpa-&gt;myvirfunc(); // 多态\tBase base;\tbase.myvirfunc();// 不是多态\tBase* ybase = &amp;base;\tybase-&gt;myvirfunc();// 多态\t\treturn 0;}\nbase.myvirfunc()不是多态的原因在于，其对应的汇编代码如下：\n00007FF6DB741BDC  lea         rcx,[base]  00007FF6DB741BE0  call        Base::myvirfunc (07FF6DB741073h)  00007FF6DB741BE5  nop  \n这里的调用是硬编码的，意味着编译时已经确定调用哪个函数。而ybase-&gt;myvirfunc();的汇编代码如下：\n00007FF6DB741BEE  mov         rax,qword ptr [ybase]  00007FF6DB741BF2  mov         rax,qword ptr [rax]  00007FF6DB741BF5  mov         rcx,qword ptr [ybase]  00007FF6DB741BF9  call        qword ptr [rax]  00007FF6DB741BFB  nop \n这里是在动态的链接，调用的是vptr指向的虚函数表。\n\n\n\n\n","categories":["Programming languages","C++"],"tags":["C++"]},{"title":"Git使用","url":"/2025/03/10/Git%E4%BD%BF%E7%94%A8/","content":"参考视频：十分钟学会正确的github工作流，和开源作者们使用同一套流程_哔哩哔哩_bilibili\n基本操作流\n先将远程仓库复制到本地\n.czvyetftbkzi{zoom:50%;}\n\n\n本地分成两个部分\n\nLocal：本地的仓库，即将要告诉git的信息\nDisk：本地的磁盘，源文件真正所在的位置\n\n\n\n新建一个新的分支\n.rjrzoppbqevv{zoom:50%;}\n编辑新的代码\n.gxoybbjndbdn{zoom:50%;}\n可以使用git diff查看disk下的文件与local中文件的区别\n保存新的代码\n.gfedlpikbfzl{zoom:50%;}\ngit add命令将会让git知道用户想要提交的文件有哪些，这些文件将被保存在暂存区\n提交新的代码\n.jdgyabyxomjj{zoom:50%;}\n通过git commit，git将会把修改的内容放到git中。但是此时，github还是不知道更新的\n推送代码\n.potnnnioelwf{zoom:50%;}\n推送后，github会出现一个新的分支\n随主分支更新\n.mnwihjqsfwmw{zoom:50%;}\n在用户提交了一个新的信息（f-commit）后，主分支可能会有更新（update），这时候就需要确认my-feature下的更新是否可以在更新后的主分支下运行。\n更新local branch\n切换到main分支\n.dnjwwnqfkbdb{zoom:50%;}\n拉取main分支的更新\n.yvtcmjxqtvgq{zoom:50%;}\n切换到my-feature分支\n.iokwhuphofcp{zoom:50%;}\n同步update修改\n.xrbztdhzjhfl{zoom:50%;}\ngit rebase意味着先把用户的修改放到一遍，把main最新的修改拿过来，在这个最新的修改基础之上，尝试把f-commit放上去。\n此时可能会出现rebase conflict，这时候就需要手动选择。\n相比较于merge，rebase是在主分支最新的提交上做出了修改。也就是说，相比较于merger会产生一个额外的merge commit，rebase会让提交更线性，更干净。但是公共分支不要使用。\n提交分支的新修改\n.xltwipsginvw{zoom:50%;}\n\n注意\n此时提交必须加上-f\n\n将代码合并到主分支\n.prokxkymmlkl{zoom:50%;}\n向项目管理者提出pull request\n项目管理者合并代码\n.jnfxbdhubylq{zoom:50%;}\nsquash操作是为了将提交的分支上的所有改变都合并成一个改变，这样可以使主分支的commit history尽可能简洁。简单来讲就是所有的改变都被放入到了update2中，但是commit的结构数量和名字改变了\n删除分支\n当提交结束后，远端的分支就可以通过delete branch删掉了。但是此时本地的git上还有这个分支。\n.vcctthumbtit{zoom:50%;}\n本地切换回主分支。\n.lsayybwhslwc{zoom:50%;}\n删除掉my-feature分支。\n拉取新的主分支\n.uvgpuhmqjzby{zoom:50%;}\n","categories":["Git"],"tags":["Git"]},{"title":"Paper Reading: Development of the relationship between visual selective attention and auditory change detection","url":"/2025/02/17/Paper-Reading%EF%BC%9ADevelopment-of-the-relationship-between-visual-selective-attention-and-auditory-change-detection/","content":"Development of the relationship between visual selective attention and auditory change detection\n文章链接：Development of the relationship between visual selective attention and auditory change detection - ScienceDirect\n\n\n视觉拥有更高的空间分辨率、听觉拥有更高的视觉分辨率 -&gt; visual selective attention and auditory change detection.\n\n\n听觉在孕期就开始发挥作用，视觉则在出生后开始发挥作用。早起听觉处理占主导，随着年龄增大，成年人转化为视觉主导。\n\n\n\n\n\nA图：成人在视觉定位任务中的 N2 pc 振幅大于儿童，表明成人在视觉选择性注意相关的神经加工强度上高于儿童。\n\n\nB图：儿童和成人的 MMN 振幅无显著差异，说明在听觉变化检测方面，二者在该成分反映的神经机制上无明显年龄差异。\n\n\n","categories":["Paper Reading"],"tags":["Paper"]},{"title":"Paper Reading: Multisensory Causal Inference in the Brain","url":"/2025/02/20/Paper-Reading%EF%BC%9AMultisensory-Causal-Inference-in-the-Brain/","content":"Multisensory Causal Inference in the Brain\n文章链接：Multisensory Causal Inference in the Brain | PLOS Biology\n\n\n融合的两个核心内容：\n\n如何判断两个或多个模态的输入来自同一个object？\n针对来自同一个object的多模态输入，该如何融合？\n\n\n\n针对这个问题，optimal probabilistic inference 又称 是核心的解决方案\n","categories":["Paper Reading"],"tags":["Paper"]},{"title":"Paper Reading: Interactions between auditory statistics processing and visual experience emerge only in late development","url":"/2025/02/17/Paper-Reading%EF%BC%9AInteractions-between-auditory-statistics-processing-and-visual-experience-emerge-only-in-late-development/","content":"Interactions between auditory statistics processing and visual experience emerge only in late development\n文章网址：Interactions between auditory statistics processing and visual experience emerge only in late development: iScience (cell.com)\n\n\n先天性和迟发性视觉剥夺对某些高阶听觉功能都有补偿作用，从而提高了相关表现。\n\n\n对于听觉处理的模式：\n\n局部特征分析：声音频率上的细微差别，比如轿车的启动声音和熄火声音\n全局表征计算：长时间的统计平均。可以理解为对轿车所有操作的声音取平均后得到的一个声音，这个声音可以代表汽车\n\n\n\n\n\n\nA展示了如何对声音进行处理，从而产生不同的样本，为B和C提供数据支持\n\n\nD展示了数据的特征，横轴表示时长，纵轴表示数据间的差异性。差异性越大，越容易分辨。\n\n\n\n\n\nD（样本辨别实验）：展示了视力正常对照组（黑色）、先天性失明组（红色）和迟发性失明组（蓝色）在样本辨别实验中的正确率。迟发性失明组在部分时长下的表现显著差于其他两组。\n\n\nE（纹理辨别实验）：呈现了三组在纹理辨别实验中的正确率。三组表现随时长增加的趋势相似。\n\n\nF 部分：计算了两个实验（样本辨别减去纹理辨别）的相对差异，展示了不同组别该差异随声音片段时长的变化。迟发性失明组在该相对差异上与其他两组存在显著差异。\n\n\nDiscussion\nAuditory statistics processing develops regardless of visual input availability\n\n\n基于过往研究，存在两种预期：一是若视觉经验对听觉处理能力发展至关重要，那么 CB （先天失明）参与者在实验中的表现会逊于视力正常者（SC）；二是鉴于先天性或早期失明个体存在听觉增强的现象，CB 组可能会出现特定的补偿机制，进而在实验中展现出更优的表现\n\n\n实验结果显示，CB 组和 SC 组在实验中的表现并无显著差异。在样本辨别实验中，两组在短时长（40、91ms）时，样本辨别表现均优于纹理辨别；在长时长（478、1093、2500ms）时，纹理辨别表现均更优。这一结果有力地证明了听觉统计处理的发展并不依赖于早期视觉经验。\n\n\nFunctional interplay between selective auditory computations and vision\n\n\n通过对比先天性失明（CB）、视力正常对照组（SC）和迟发性失明（LB）三组的表现，发现虽然早期视觉对听觉统计处理的典型发展并非必需，但在后期发展阶段，失明仍会影响局部特征的处理。\n\n听觉感知功能（例如频率检测和振幅调制）可能在独立于视觉输入的情况下发展，只有在功能发育完成后，感官之间才会产生交互作用。\n后天失明的人可能更注重统计平均而非时间细节，因为其有助于在日常环境中识别声音对象。\n\n\n\nConclusions\n\n\n听觉和视觉都是先独自发展，待各自成熟后才交互作用共同发展。\n\n\n","categories":["Paper Reading"],"tags":["Paper"]},{"title":"Paper Reading: Visual Infuences on Auditory Behavioral, Neural, and Perceptual Processes: A Review","url":"/2025/02/04/Paper-Reading%EF%BC%9AVisual-Infuences-on-Auditory-Behavioral,-Neural,-and-Perceptual-Processes-A-Review/","content":"Visual Infuences on Auditory Behavioral, Neural, and Perceptual Processes: A Review\npaper link: Visual Influences on Auditory Behavioral, Neural, and Perceptual Processes: A Review (springer.com)\n文章主要的目标：解释信息是如何整合的。整合的目的是对冗余和互补信息进行处理\n后半部分更多的是在说视觉如何帮助听觉：比如帮助听力损失的人\nVisual Influences on Auditory Perception: Psychophysical Evidence in Humans\nVision Can Enhance Auditory Perceptual Performance\n\n\n一种感觉模态的信息，无论与任务是否相关，都能对另一种感觉模态的感知判断产生影响。这说明不同感觉模态之间存在着密切的联系和相互作用，不是孤立运作的。\n\n\nEnhancement of Auditory Perceptual Performance by Task‑Irrelevant Visual Information\n\n\n与任务无关的视觉能够增强对于听觉的感知。举例而言就是当一个人在判别声音强度的任务时，加入灯光信息会让受试者误认为声音变强了。\n\n\n当视觉刺激领先于听觉刺激时，人们最容易感知到两者是同时发生的。\n\n\nSpatial Ventriloquism：空间腹语效应\n解释：就是在空间中，尽管声音是从B点发出的，但是因为视觉看到A点更符合声音的发出条件（比如电视里一个人在说话），那么就会使人认为声音来自A点。\n\n\n只有当视觉信息可靠性足够高的时候，这种效应才会产生：即视觉对听觉占主导地位\n\n可靠性足够高：听觉信息和视觉信息在空间和时间上的一致性强\n\n\n\n\n提示\n当听觉信息与在空间和时间上一致的视觉信息配对时，听觉感知表现能够得到提升，无论这些视觉信息与任务是否相关。\n\nMechanistic Principles of Visual Influences on Auditory Perception\n\n自下而上是正向传播，自上而下则是反向传播\n\n\n对于Computations部分的解释：蓝色是视觉感知的概率分布，红色是听觉感知的概率分布，紫色是融合后的概率分布，向下的黑色箭头是对结果的最优估计。\n\n\n黑色垂直线表示causal inference、fusion和sensory processing有可能发生的位置\n\n\n\n注意\nsensory processing图中黑色箭头为啥不指概率最高的视觉？\n\n","categories":["Paper Reading"],"tags":["Paper"]},{"title":"Python拾遗","url":"/2025/02/21/Python%E6%8B%BE%E9%81%97/","content":"代码仓库：https://gitee.com/qianminghuang/python-learning.git\n函数\n\n提示\n当函数没有返回值的时候，函数默认返回None。\n\nNone的应用类型\n\n\n可以用于if判断，None等价于False\n\n\n用于声明无初始内容的变量\nname = None # 表示后续再给name赋值\n\n\n变量的作用域\n在函数内部，可以使用global关键词来设置全局变量。\ndef test():    global a # 将函数内部的变量声明为全局变量    a = 10    print(f\"a在函数中的地址:{id(a)},值为{a}\")a = 20print(f\"a在函数外的地址:{id(a)},值为{a}\")test()\n输出：\n.pwbmtjxybtgr{zoom: 67%;}\nLambda匿名函数\n函数的定义有两种：\n​\tdef关键字的方式，定义有名称的函数，可以重复使用。\n​\tlambda关键字，定义匿名函数，只能临时使用一次。\n匿名函数的定义语法：\nlambda 传入参数: 函数体\n注意，此处函数体只能一行。\n具体案例：\ndef test_func(compute):    result = compute(1, 2)    print(result)def compute(x, y):    return x + ytest_func(compute)# 匿名函数test_func(lambda x, y: x + y)\n输出：\n​\t\nlambda函数具体应用场景：\n\n\n临时构建一个函数，只用一次的场景\n\n\n函数体只用一行\n\n\n函数参数\n不定长参数\n位置传递的不定长参数\n以*开头的参数，其会根据传进参数的位置合并出一个元祖。\ndef user_info_1(*args):    print(args)user_info_1(1, 2, 3, 4, 5)user_info_1(\"test\", 10)\n输出：\n.nvmenolsfhen{zoom: 50%;}\n关键字传递的不定长参数\n以**开头，参数是键值对的形式，返回的是一个字典。\ndef user_info_2(**kwargs):    print(kwargs)    user_info_2(name=\"test\", age=10, sex = \"男\")user_info_2(10,20) # 报错，不接受位置参数\n输出：\n.wbhjctjpoywn{zoom: 67%;}\n结合使用：\ndef user_info_3(*args, **kwargs):    print(args)    print(kwargs)user_info_3(1, 2, 3, 4, 5, name=\"test\", age=10, sex = \"男\")user_info_3(10,20)user_info_3(1, 2, name=\"test\", 4, age=10, sex = \"男\") # 报错，位置参数不能在关键字参数后面\n输出：\n.fbcckwwncuax{zoom:67%;}\n函数作为参数\ndef test_func(compute_func, a, b):    result = compute_func(a, b) + 10    print(result)def compute(x, y):    return x + ytest_func(compute, 1, 2)\n输出：\n.imvmlzywibfi{zoom: 67%;}\n本质上传递的是代码的执行逻辑\n数据类型\n.jmvluxuveflw{zoom: 67%;}\n\n\n列表：[]，一批数据，可修改\n\n\n元组：()，一批数据，不可修改\n\n\n集和：set()  {}，用于去重操作\n\n\n异常\n了解异常\n异常：程序运行的时候检测到一个错误，这个错误将导致Python解释器无法继续执行。\n也可以理解为一个Bug。\n异常的捕获方式\n\n\n异常捕获的目的\n对可能出现的异常（bug），提前做准备。具体而言就是对Bug进行提醒，并且让整个程序继续运行。这样就可以避免因为一个Bug而导致的整个程序的停止。\n\n\n捕获常规异常\n基本语法：\n  try:\t可能错误的代码except:\t如果出现异常执行的代码\n案例：\n  try:\tf = open(\"text.txt\",'r')except:    print(\"出现了异常，使用新的方案\")\tf = open(\"linux.txt\",'w')\n当try语句中出现异常后，程序不会抛出异常，而是使用except来让程序继续运行\n捕获指定的异常\n基本语法：\ntry:\t可能错误的代码except 指定的异常 as 异常的别名:\t如果出现异常执行的代码\n案例：\ntry:    print(name) # 注意，前文并没有定义nameexcept NameError as e:     print(\"name未定义\")    print(e) # 把异常打印出来\n结果：\n.ylqbweetxvqf{zoom:80%;}\n捕获多个异常\n基本语法：\ntry:    可能错误的代码except (异常1, 异常2): # 也可以：except (异常1, 异常2) as e\t如果出现异常执行的代码\n捕获所有异常\n最简单的try   except语句就可以捕获所有异常了，但是没法对所捕获到的异常进行输出。\n基本语法：\ntry:    可能错误的代码except Exception as 异常的别名: # Exception可以被认为是所有异常的父类    如果出现异常执行的代码\n通过输出异常的别名就可以看到捕获的异常是什么。\nelse 与 finally\n用于表示在没有异常的时候该执行什么行为。\n基本语法：\ntry:    可能错误的代码except Exception as 异常的别名:    如果出现异常执行的代码else:    没有异常时执行的代码finally:    有没有异常都执行的代码\n\n提示\nfinally中一般都是用来执行资源关闭操作，比如文件的关闭\n\n案例：\ntry:    print(\"正常执行\")except Exception as e:    print(e)else:    print(\"没有异常\")\n输出：\n.tpsujplrghuu{zoom:67%;}\n异常的传递\n假设有函数调用关系如下\nmain()|--func01()   |--func02()\n当func02()的代码中出现异常后，异常会向上逐级传递（从func02() -&gt; func01() -&gt; main() ），这条传递线上的任意一个函数有对异常的捕获都将使程序可以继续执行。\n","categories":["Programming languages","Python"],"tags":["Python"]},{"title":"Hello World","url":"/2025/01/15/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start\nCreate a new post\n$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server\n$ hexo server\nMore info: Server\nGenerate static files\n$ hexo generate\nMore info: Generating\nDeploy to remote sites\n$ hexo deploy\nMore info: Deployment\n"},{"title":"如何配置Hexo","url":"/2025/02/02/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEHEXO/","content":"配置图床\n参考链接：Github+PicGo搭建个人免费图床 - misakivv - 博客园 (cnblogs.com)\n对于博客页的照片上传\n参考解决链接：[2024] hexo图片无法加载究极解决方案_hexo图片显示不出来-CSDN博客\n对于markdown渲染器的优化\n参考链接（优选）：【Hexo】更高级的Markdown渲染器 | Everett Rain\n参考链接：【Hexo】选择更高级的Markdown渲染器_hexo-renderer-marked-CSDN博客\n对于渲染器优化后，mathjax用不了的解决方案\n\n\n在修改了渲染器后，会发现mathjax用不了，此时就需要针对新的渲染器安装一个插件\n如图所示：\n\n\n\n解决方案：\n\n下载一个插件：\n\n$ npm install markdown-it-mathjax3\n\n\n在hexo的_config.yml文件中，加上这个插件的名字\n\n\n\n随后就可以啦！\n\n\n\n\n测试区\n二级标题测试\n三级标题测试\n四级标题测试\n五级标题测试\n六级标题测试\ntest\ntest\ntest\ntest\ntest\n\n\n对于代码的测试\n\n\n# 此处作为代码测试import numpy as npa = np.array([1,2,3])\n\n\n对于公式的测试\n\n\n​\t对于句子内部的公式：例如\n\n\n对于图片的测试\n\n本地图片：\n\n\n\n.kcykcqscuhyb{zoom:33%;}\n\n\n​\t网络图片\n\n\n\n折叠，展开内容\n\n\n语法：\n\n\n+++ **点击折叠**这是被隐藏的内容+++\n\n\n效果：\n\n 点击折叠这是被隐藏的内容\n\n\n\n自定义容器\n\n\n效果\n\n提示\n这是一个提示\n\n\n注意\n这是一个警告\n\n\n警告\n这是一个危险信号\n\n\n成功\n这是一个成功信号\n\n\n\n语法：\n::: tips**提示**这是一个提示:::::: warning**注意**这是一个警告:::::: danger**警告**这是一个危险信号:::::: success**成功**这是一个成功信号:::\n\n\n文本高亮测试：\n\n这是一句测试的文本。\n\n\n\n","categories":["Hexo","解决方案"],"tags":["Hexo"]},{"title":"深度学习：深度生成模型","url":"/2025/02/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B/","content":"深度学习：深度生成模型\n\n判别式模型和生成式模型\n\n判别式：学习类别的边界（比如CNN、RNN）\n生成式：学习数据的分布（VAE、GAN）。比判别式更加复杂\n\n\n\n蒙特卡洛方法\n采样 sampling\n\n\n采样可以减少积分运算量，便于统计推断和模型优化\n\n\n蒙特卡洛采样：从概率分布中抽出样本，得到分布的近似。样本越多，近似的越准\n\n\n\n​\t其中表示的是采样点\n\n可以看出，在1000个样本的时候，采样的最准\nImportance Sampling\n\n\n用于估计难以采样的分布的期望值。即不好求\n\n\n用易于采样的参考分布生成样本，然后用权重系数调整估计\n\n此处不好采样，就用如高斯分布等更为简单的来近似\n\n\n马尔科夫链蒙特卡洛方法\n\n\nMarkov Chain Monte Carlo (MCMC)\n\n\n一种动态的采样方法。\n\n使用状态转移矩阵，从起始状态开始，转移出一系列的状态，这一系列的状态就是最后的采样结果\n\n\n\n\n好处：不用在整个分布空间中均匀采样，可以进一步提升采样的效率\n\n\n变分推断（Variational Inference）\n参数估计\n\n\n机器学习的本质：从数据中估计出参数\n\n\n两个学派：\n\n\n第一个学派（频率学派）认为，数据就是客观存在的，不受任何影响，所以直接求，即先验概率\n\n\n第二个学派（贝叶斯学派）认为，观测到的数据会受到隐变量的影响，所以他们求的是后验概率。\n.nydssgqxlxbx{zoom:50%;}\n\n\n\n\n\n\n","categories":["Artificial Intelligence","Deep Learning"],"tags":["Deep Learning"]}]